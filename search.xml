<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis_Intro</title>
      <link href="/2021/07/07/redis-intro/"/>
      <url>/2021/07/07/redis-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Introduction"><a href="#Redis-Introduction" class="headerlink" title="Redis Introduction"></a>Redis Introduction</h1><h2 id="一、NoSQL-概述"><a href="#一、NoSQL-概述" class="headerlink" title="一、NoSQL 概述"></a>一、NoSQL 概述</h2><h3 id="1、为什么要用-NoSQL"><a href="#1、为什么要用-NoSQL" class="headerlink" title="1、为什么要用 NoSQL"></a>1、为什么要用 NoSQL</h3><p>大数据时代：</p><p>一般的数据库无法处理大数据，2006 年 Hadoop 发布</p><ul><li>单机 Mysql <ul><li>App ==》DAL ==》Mysql</li><li>这种情况下，网站的瓶颈：<ul><li>数据量如果太大，一个机器不能满足需求</li><li>数据量查过 300w 就需要使用索引了（B+ Tree），一个机器内存也放不下</li><li>访问量（读写混合）一个服务器无法承担</li></ul></li></ul></li></ul><ul><li>Memcached（缓存）+ MySQL + 垂直拆分（读写分离）<ul><li>读写分离：将数据库按照功能进行分类，不同 MySQL 数据库的功能不一样</li><li>问题：如何保证数据库一致性，以及数据库查询效率</li><li>使用缓存，同时不同的 MySQL 数据库需要同步</li><li>App ==&gt; DAL ==&gt; Cache ==&gt; MySQL 1 2 3</li><li>发展过程：优化数据结构和索引（底层）==&gt; 文件缓存（IO）–&gt; Memcached</li></ul></li></ul><ul><li>分库分表 + 水平拆分 + MySQL 集群<ul><li>App –&gt; DAL –&gt; 集群1 集群 2 3 4</li><li>本质：数据库（读、写），缓存解决大部分读的问题，分库分表解决大部分写的问题</li><li>早些年 MyISAM：表锁，十分影响效率，高并发会产生严重问题</li><li>现在 Innodb：行锁</li><li>慢慢的开始使用<code>分库分表</code>解决写的压力</li><li>MySQL 提出表分区（基本不使用了）、MySQL 的集群（很好满足了那个年代的大部分需求）</li></ul></li></ul><ul><li>最近的年代<ul><li>MySQL 等关系型数据库不够用了，数据量很多，变化很快</li><li>图数据库、json（BSON）</li><li>使用 MySQL 的时候使用它存一些比较大的文件、图、博客文章等等，数据库很大，效率会变低，我们应该使用特定的数据库来处理这些数据，MySQL 的压力就会变小</li></ul></li></ul><p><strong>目前基本的互联网项目：</strong></p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/test.png"></p><blockquote><p>为什么要用 NoSQL</p></blockquote><p>用户个人信息，社交网络，地理位置，用户产生的数据，用户日志爆发式增长</p><p>NoSQL 数据库，可以很好的处理上述情况</p><h3 id="2、什么是-NoSQL"><a href="#2、什么是-NoSQL" class="headerlink" title="2、什么是 NoSQL"></a>2、什么是 NoSQL</h3><blockquote><p>NoSQL</p></blockquote><p>NoSQL = Not Only SQL</p><p>泛指非关系型数据库</p><p>很多数据类型的存储不需要固定格式（关系型格式固定），不需要多余的操作就可以横向扩展（Map&lt;String, Object&gt;）, Redis 使用 键值对 存储</p><blockquote><p>NoSQL 特点</p></blockquote><p>1、方便扩展（数据之间没有关系）</p><p>2、大数据量，高性能（Redis 一秒写 8 万次，读取 11 万次，NoSQL 的缓存记录级，是一种细粒度的缓存，性能会比较高）</p><p>3、数据类型是多样的 （<code>不需要事先设计数据库</code> 随取随用，如果是数据量非常大的数据库，很难设计）</p><p>4、传统 RDBMS 和 NoSQL</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">传统的 RDBMS<span class="token punctuation">-</span> 结构化阻止<span class="token punctuation">-</span> SQL<span class="token punctuation">-</span> 数据和关系都存在单独的表中<span class="token punctuation">-</span> 操作语言，数据定义<span class="token punctuation">-</span> 严格的一致性（ACID）<span class="token punctuation">-</span> 基础的事务<span class="token punctuation">-</span> <span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">NoSQL<span class="token punctuation">-</span> 不仅仅是数据<span class="token punctuation">-</span> 没有固定的查询语言<span class="token punctuation">-</span> 键值对，列存储、文档存储、图形数据库（社交关系等等）<span class="token punctuation">-</span> 最终一致性<span class="token punctuation">-</span> CAP 定义 和 BASE （异地多活）<span class="token punctuation">-</span> 高性能，高可用，高扩展性<span class="token punctuation">-</span> <span class="token punctuation">...</span><span class="token punctuation">...</span>..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>了解 ：3V + 3高</p></blockquote><p>大数据时代的 3 V：主要是描述问题</p><ol><li>海量 Volume</li><li>多样 Variety</li><li>实时 Velocity</li></ol><p>大数据时代的 3 高：主要是对程序的要求</p><ol><li>高并发</li><li>高可拓 </li><li>高性能</li></ol><p>真正在公司中的实践：NoSQL + RDBMS 结合使用</p><h3 id="3、阿里巴巴架构演进"><a href="#3、阿里巴巴架构演进" class="headerlink" title="3、阿里巴巴架构演进"></a>3、阿里巴巴架构演进</h3><p>敏捷开发、极限编程</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">1、商品基本信息名称、价格、商品信息关系型数据库就可以解决了2、商品的描述、评论（文字比较多）文档型数据库：MongoDB3、图片分布式文件系统 FastDFS<span class="token punctuation">-</span> 淘宝自己的 TFS<span class="token punctuation">-</span> Google 的 GFS<span class="token punctuation">-</span> Hadoop HDFS<span class="token punctuation">-</span> 阿里云的 OSS4、商品关键字（搜索）<span class="token punctuation">-</span> 搜索引擎 solr elasticsearch<span class="token punctuation">-</span> 淘宝 ISerach5、商品热门波段信息<span class="token punctuation">-</span> 内存数据库<span class="token punctuation">-</span> redis、tair、memcache。。。。6、商品交易，外部的支付接口<span class="token punctuation">-</span> 三方应用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大型互联网应用的问题：</p><ul><li>数据类型太多</li><li>数据源繁多，经常重构</li><li>数据要改造，大面积改造</li></ul><p>解决问题：</p><ul><li>加一层</li></ul><h3 id="4、NoSQL-的四大分类"><a href="#4、NoSQL-的四大分类" class="headerlink" title="4、NoSQL 的四大分类"></a>4、NoSQL 的四大分类</h3><p>KV 键值对：</p><ul><li><strong>Redis</strong></li><li>Redis + Tair</li><li>Redis + memechae</li></ul><p>文档型数据库（bson 格式 和 json 类似）：</p><ul><li><strong>MongoDB</strong>（一般必须要掌握）<ul><li>MongoDB 是一个基于分布式文件存储的数据库，基于 C++ 编写，主要用于处理大量的文档</li><li>MongoDB 是一个介于关系型数据库和非关系型数据库中间的产品。它属于 NoSQL，但是它在非关系型数据库中功能最丰富，最接近关系型数据库</li></ul></li><li>ConthDB</li></ul><p>列存储数据库：</p><ul><li><strong>HBase</strong></li><li>分布式文件系统</li></ul><p>图关系型数据库：</p><ul><li>用于存储关系，比如：朋友圈社交网络</li><li><strong>Neo4j</strong>，InfoGrid</li></ul><h2 id="二、Redis-入门"><a href="#二、Redis-入门" class="headerlink" title="二、Redis 入门"></a>二、Redis 入门</h2><p>Redis（Remote Dictionary Server），远程字典服务</p><p>也称为结构化数据库</p><p><strong>作用：</strong></p><ol><li>内存存储、持久化（<strong>rdb、aof</strong>）</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器</li><li>………………</li></ol><p><strong>特定：</strong></p><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事物</li><li>……</li></ol><p><strong>需要用到的配置</strong></p><ul><li><p>官网：<a href="http://www.redis.cn/documentation.html">http://www.redis.cn/documentation.html</a></p></li><li><p>端口：6379</p></li><li><p>Linux 下安装</p></li></ul><h3 id="1、Linux-中安装-Redis"><a href="#1、Linux-中安装-Redis" class="headerlink" title="1、Linux 中安装 Redis"></a>1、Linux 中安装 Redis</h3><p>见另一篇博文：</p><p><a href="https://naivekyo.github.io/2021/07/06/centos7-install-redis/">Linux 安装 Redis</a></p><h3 id="2、测试性能"><a href="#2、测试性能" class="headerlink" title="2、测试性能"></a>2、测试性能</h3><p>redis-benchmark 是一个压力测试工具</p><p>官方自带的性能测试工具</p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/benchmark.png"></p><p>简单测试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 测试：100 个并发连接 100000 请求</span><span class="token comment"># 如果 redis 设置有密码，则需要加上 -a 密码</span>redis-benchmark -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6379</span> -c <span class="token number">100</span> -n <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3、基础知识"><a href="#3、基础知识" class="headerlink" title="3、基础知识"></a>3、基础知识</h3><p>redis 默认有 16 个数据库，默认使用的是第 0 个数据库</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and 'databases'-1databases 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用 <code>select </code>进行切换数据库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token keyword">select</span> <span class="token number">2</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> dbsize <span class="token comment"># 查看数据库大小</span><span class="token comment"># 查看当前数据库所有的 key</span>keys *<span class="token comment"># 清空所有数据</span>flushall <span class="token comment"># 清空所有数据库</span>flushdb<span class="token comment"># 清除当前数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>Redis 是单线程的</strong></p></blockquote><p>Redis 非常快，是基于内存操作，所以 CPU 不是 Redis 的性能瓶颈，Redis 受机器的内存和网络带宽影响，既然可以使用单线程，就使用单线程。</p><p>Redis 使用 C 语言编写，官方提供的数据是 100000+ 的 QPS，不比 Memecache 差。</p><p><strong>Redis 为什么单线程还是这么快？</strong></p><ol><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（上下文切换也会消耗资源）一定比单线程效率高</li></ol><p>先去了解 CPU &gt; 内存 &gt; 硬盘 （速度）</p><p>核心：<strong>Redis 将所有的数据全部放在内存中，所以说使用单线程效率就是最高的</strong>，多线程上下文切换是需要消耗时间的，对于内存系统，没有上下文切换效率就是最高的。多次读写都是在一个 CPU，在内存情况就是最佳方案。</p><h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p>Redis 是一个开源的，内存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件MQ</strong>。它支持多种类型的数据结构，如 字符串（Strings），散列（hashs）、列表（lists）、集合（sets）、有序集合（sorted sets）与范围查询，bitmaps，hyperloglogs和地理空间（geospatial）索引半径查询。Redis 内置了 复制（replication），LUA 脚本（lua scripting），LRU 驱动事件（LRU eviction），事物（transactions）和不同级别的 磁盘持久化（persistence），并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availablity）（其实就是搭建集群）</p><h3 id="1、Redis-Key"><a href="#1、Redis-Key" class="headerlink" title="1、Redis-Key"></a>1、Redis-Key</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 判断某个 key 是否存在</span>exists 键名<span class="token comment"># 将当前数据库下的某个 key 移动到其他的数据库</span>move 键名 其他数据库编号<span class="token comment"># 给某个 key 设置过期时间</span>expire 键名 秒数<span class="token comment"># 查看某个 key 的剩余有效期</span>ttl 键名<span class="token comment"># 查看某个 key 的类型</span><span class="token builtin class-name">type</span> 键名<span class="token comment"># 删除 key</span>del 键名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>Java 中可以使用 <code>Jedis</code> 连接 Redis 服务器，进行相关的操作</strong></p></li><li><p><strong>单点登录</strong> 可以给用户数据设置过期时间</p></li><li><p><a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p></li></ul><h3 id="2、String（字符串）"><a href="#2、String（字符串）" class="headerlink" title="2、String（字符串）"></a>2、String（字符串）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 向字符串类型的 key 追加字符</span><span class="token comment"># 如果要追加的 key 不存在就相当于 set key</span>append 键名 追加字符<span class="token comment"># 查看字符串类型 key 的长度</span>strlen 键名<span class="token comment"># value 加 1</span>incr 键名<span class="token comment"># value 减 1</span>decr 键名<span class="token comment"># 加减操作的步长</span>incrby 键名 步长decrby 键名 步长<span class="token comment"># 字符串范围，默认从 0 开始计数</span>getrange 键名 开始 结束<span class="token comment"># 查看完整的字符串</span>getrange 键名 <span class="token number">0</span> -1<span class="token comment"># 替换字符串，从某个下标开始替换</span>setrange 键名 offset value<span class="token comment"># 如果当前键存在 setex (set with expire) 设置过期时间</span>setex 键名 过期时间 新的值<span class="token comment"># 如果当前键不存在 setnx (set if not exist) 就设置这个 key</span>setnx 键名 新的值<span class="token comment"># 批量设置key</span>mset key1 value1 key2 value2 <span class="token punctuation">..</span>.<span class="token comment"># 批量获取</span>mget key1 key2 key3 <span class="token punctuation">..</span>.<span class="token comment"># 批量设置，如果遇到不存在的值则不会生效（原子性）</span>msetnx key1 newValue key4 value4<span class="token punctuation">..</span>. <span class="token comment"># key4 不存在，则该行不生效</span><span class="token comment"># 先 get 再 set</span><span class="token comment"># 先 get 如果不存在，则返回 nil，同时再 set，创建该 key</span><span class="token comment"># 先 get 如果存在，再 set，会覆盖原来的值</span>getset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>例如网站浏览量的 views 的值是通过缓存实现的，创建 <code>set views 0</code>，每次浏览使用 <code>incr views</code> 让其自动 +1</p></li><li><p><strong>setnx</strong>：<strong>在分布式锁中会很常用，它可以保证当前值存在</strong></p></li><li><p><strong>msetnx：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 对象</span><span class="token builtin class-name">set</span> user:1 <span class="token punctuation">{</span>name:zhangsan,age:3<span class="token punctuation">}</span> <span class="token comment"># 设置 user:1 对象，值为 json 字符串</span><span class="token comment"># 另一种方式，批量设置和获取</span><span class="token comment"># 这里的 key 设计的很巧妙: user:{id}:{filed}</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> mset user:1:name zhangsan user:1:age <span class="token number">21</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> mget user:1:name user:1:age<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"zhangsan"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"21"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>String 类型的使用场景：value 除了是字符串还可以是数字</p><ul><li>计数器</li><li>统计多单位数量</li><li>粉丝数</li><li>对象缓存存储</li></ul></li></ul><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><p>基本的数据类型，列表</p><p>给 List 添加一些规则就可以实现一些特殊的操作（栈、队列）</p><p>在 redis 中，可以将 list 做成 栈、队列</p><p><strong>所有的 List 命令都是以 l 开头的</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpush list one<span class="token comment"># 将一个值或多个值插入列表的头部(左)</span>rpush list four <span class="token comment"># 将一个值或多个值插入列表的尾部(右)</span>lpush list twolpush list threelrange list <span class="token number">0</span> -1  <span class="token comment"># 取一定范围的列表中的值</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"three"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"two"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"one"</span>lrange list <span class="token number">0</span> <span class="token number">1</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"three"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"two"</span><span class="token comment"># 移除值</span>lpop list <span class="token comment"># 默认只移除一个</span>lpop list <span class="token number">2</span> <span class="token comment"># 移除头部两个值</span>rpop list <span class="token comment"># 一样的，只不过从尾部开始</span><span class="token comment"># 下标操作</span>lindex list <span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token comment"># 下标从 0 开始</span><span class="token comment"># 长度</span>llen 列表名<span class="token comment"># 移除指定的值</span>lrem list 数量 值 <span class="token comment"># 从列表头开始移除指定数量的某一个值(精确匹配)</span><span class="token comment"># 保留一部分元素（截断操作）</span>ltrim list start end <span class="token comment"># 保留该下标范围内的元素</span><span class="token comment"># 移除列表的最后一个元素并且将它添加到一个新的列表的头部</span>rpoplpush <span class="token builtin class-name">source</span> destination <span class="token comment"># 如果 destination 不存在则新建列表</span><span class="token comment"># 判断列表是否存在</span>exists 列表名<span class="token comment"># 更新某个列表指定索引处的值，前提该列表必须存在</span>lset 列表名 索引 值<span class="token comment"># 在列表中指定值的前面或后面插入新的值</span>linsert key BEFORE<span class="token operator">|</span>AFTER pivot element <span class="token comment"># pivot 指具体的值</span>linsert mylist before <span class="token string">"v1"</span> <span class="token string">"v4"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>小结</p></blockquote><ul><li>list 实际上是一个<strong>链表</strong></li><li>如果 key 不存在，就会创建新的链表</li><li>如果 key 存在，则新增内容</li><li>如果移除了所有值，得到空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高，但是如果对中间元素进行操作，效率会变低</li></ul><p>消息排队、消息队列、栈</p><h3 id="4、Set（集合）"><a href="#4、Set（集合）" class="headerlink" title="4、Set（集合）"></a>4、Set（集合）</h3><p>set 中的值不能重复</p><p>Redis 中涉及到 set 的命令都是 s 开头</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建 set 并添加元素</span>sadd myset <span class="token string">"hello"</span><span class="token punctuation">..</span>.<span class="token comment"># 获取 set 的所有元素</span>smembers myset<span class="token comment"># 判断某个值是不是 set 的成员</span>sismember myset <span class="token string">"hello"</span><span class="token comment"># 移除 set 中的指定元素</span>srem myset <span class="token string">"hello"</span><span class="token comment"># 查看 set 的长度</span>scard myset<span class="token comment"># redis set 封装了获取随机元素的 api</span>srandmember myset <span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token comment"># 随机获取指定数量的元素</span><span class="token comment"># 随机删除指定数量的 key</span>spop myset <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token comment"># 从一个set中将指定的值移动到另外的一个set中</span>smove <span class="token builtin class-name">source</span> destination membersmove set1 set2 <span class="token string">"v1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>set 是无序不重复集合，可以做到抽取随机元素</p></li><li><p>共同关注（并集）</p><ul><li>差集、交集、并集</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 差集</span><span class="token function">sdiff</span> key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment"># 交集</span>sinter key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment"># 并集</span>sunion key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="5、Hash（散列）"><a href="#5、Hash（散列）" class="headerlink" title="5、Hash（散列）"></a>5、Hash（散列）</h3><p>可以理解为 key-map</p><p>原本的 k-v 中 value 变成了 map</p><p>Redis 中所有与 hash 相关的命令都是以 h 开头</p><p>hash 本质和 String 类型没有太大区别，还是一个简单的 key-value</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 设置 hash</span>hset myhash field value<span class="token comment"># 获取 hash</span>hget myhash field<span class="token comment"># 设置或者获取多个 hash</span>hmset myhash field1 hello field2 worldhmget myhash field1 field2<span class="token comment"># 获取一个 hash 中所有 key-value</span>hgetall myhash<span class="token comment"># 删除至少一个 field</span>hdel myhash field1 <span class="token punctuation">..</span>.<span class="token comment"># 获取一个 hash 的 key 的数量</span>hlen myhash<span class="token comment"># 判断 hash 中某个 key 是否存在</span>hexists myhash field1<span class="token comment"># 只获得所有的 field </span>hkeys myhash<span class="token comment"># 只获取所有的 value</span>hvals myhash<span class="token comment"># 让某个 field 对应的 value 自增或自减 incr decr</span><span class="token comment"># 指定增量</span>hincrby myhash field3 <span class="token number">3</span>hincrby myhash field3 -1<span class="token comment"># 如果存在</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hsetnx myhash field4 <span class="token builtin class-name">test</span> <span class="token comment"># 如果不存在就可以使用</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hsetnx myhash field4 tes <span class="token comment"># 如果存在就不可以使用</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash 可以存放一些变更的数据：<code>hmset user:1 name kyo age 11</code></p><p>尤其是用户信息的保存或者经常变动的信息。</p><p><strong>hash 更适合 对象 的存储</strong></p><p><strong>String 更加适合字符串存储</strong></p><h3 id="6、Zset（有序集合）"><a href="#6、Zset（有序集合）" class="headerlink" title="6、Zset（有序集合）"></a>6、Zset（有序集合）</h3><p>在 set 的基础上增加了一个值，zset k1 score1 v1，中间加上一个标志用于声明优先级</p><p>zset 相关的命令都是以 z 开头</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加至少一个值</span>zadd myset <span class="token number">1</span> onezadd myset <span class="token number">2</span> two <span class="token number">3</span> three<span class="token comment"># 获取值</span>zrange myset <span class="token number">0</span> -1<span class="token comment"># 实现排序</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd salary <span class="token number">2500</span> userOne<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd salary <span class="token number">1000</span> userTwo<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd salary <span class="token number">500</span> userThree<span class="token comment"># 根据 score 排序，升序排列，显示所有数据，负无穷到正无穷</span>zrangebyscore salary -inf +inf<span class="token comment"># min 和 max 默认是 大于等于和小于等于，如果是半闭合，可以这样</span>zrangebyscore salary <span class="token punctuation">(</span><span class="token number">100</span> <span class="token number">500</span><span class="token comment"># 根据 score 排序，降序排列</span>zrevrangebyscore salary +inf -inf withscores<span class="token comment"># 移除指定元素</span>zrem salary userOne<span class="token comment"># 查看 Zset 中元素的个数</span>zcard salary<span class="token comment"># 查看符合指定区间的元素个数</span>zcount salary <span class="token number">100</span> <span class="token number">700</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多看官方文档：<a href="https://redis.io/commands">https://redis.io/commands</a></p><p>案例思路：zset 排序 存储班级成绩表、工资表排序</p><p>普通消息：1、重要消息：2，带权重进行判断</p><p>排行榜应用实现，取 TopN</p><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="1、geospatial（地理位置）"><a href="#1、geospatial（地理位置）" class="headerlink" title="1、geospatial（地理位置）"></a>1、geospatial（地理位置）</h3><p>朋友的定位、附近的人、打车距离计算</p><p>Redis 的 Geo 在 Redis3.2 版本就已经推出了，这个功能可以推算地理位置的信息，两地之间的距离，周围的人</p><p>可以查询一些测试数据 ：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p><p>Redis 中所有和 geospatial 相关的命令都是以 geo 开头</p><blockquote><p>geoadd</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 添加地理位置</span><span class="token comment"># 规则：两极无法直接添加，我们一般会下载城市数据，通过 Java 程序一次性导入</span><span class="token comment"># 参数 key (纬度、经度、名称)</span><span class="token comment"># 有效经度从-180到180度</span><span class="token comment"># 有效纬度从 -85.05112878 到 85.05112878 度</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geoadd china:city <span class="token number">30.24</span> <span class="token number">120.16</span> hangzhou <span class="token number">34.26</span> <span class="token number">108.96</span> xian<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span class="token comment"># 官网例子</span>GEOADD Sicily <span class="token number">13.361389</span> <span class="token number">38.115556</span> <span class="token string">"Palermo"</span> <span class="token number">15.087269</span> <span class="token number">37.502669</span> <span class="token string">"Catania"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>geopos</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 获取指定城市的维度和经度</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geopos Sicily Palermo Catania<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"13.36138933897018433"</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"38.11555639549629859"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"15.08726745843887329"</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"37.50266842333162032"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>geodist</p></blockquote><p>两者之间的距离</p><p>单位</p><ul><li>m 米</li><li>km 千米</li><li>mi 英里</li><li>ft 英尺</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看的是直线距离</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geodist Sicily Palermo Catania m<span class="token string">"166274.1516"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geodist Sicily Palermo Catania km<span class="token string">"166.2742"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geodist Sicily Palermo Catania ft<span class="token string">"545518.8700"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> geodist Sicily Palermo Catania mi<span class="token string">"103.3182"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>georadius 以给定的经纬度为中心，找出某一半径内的元素</p></blockquote><p>附近的人（获取所有附近的人的地址：定位）通过半径来查询</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>  GEORADIUS Sicily <span class="token number">15</span> <span class="token number">37</span> <span class="token number">200</span> km WITHDIST<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Palermo"</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"190.4424"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Catania"</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"56.4413"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>  GEORADIUS Sicily <span class="token number">15</span> <span class="token number">37</span> <span class="token number">200</span> km<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Palermo"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"Catania"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>georadiusbymember</p></blockquote><p>找出位于指定范围内的元素，中心点是由给定的位置元素决定的</p><blockquote><p>geohash</p></blockquote><p>返回一个或多个位置元素的 Geohash 表示</p><p>目前用不到</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么距离就越近</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>GEO 底层实现原理：Zset，可以使用 Zset 命令操作 geo</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 geospatial 中所有数据</span><span class="token comment"># zset 的所有命令都适用于 geospatial</span>zrange Sicily <span class="token number">0</span> -1 <span class="token comment"># 移除指定元素</span>zrem Sicily Palermo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、hyperloglog"><a href="#2、hyperloglog" class="headerlink" title="2、hyperloglog"></a>2、hyperloglog</h3><blockquote><p>什么是基数？</p></blockquote><p>A{1, 3,  5, 7, 8, 7}</p><p>B{1, 3, 5, 7, 8}</p><p>基数：集合的个数（要求没有重复）</p><p><strong>简介：</strong></p><p>Redis 2.8.9 就更新了 Hyperloglog 数据结构</p><p>Redsi Hyperloglog 基数统计的算法</p><p>网页的 UV（一个人访问一个网站，但是还是算作一个人）</p><p>传统的方式：set 保存用户的 Id，就可以统计 set 中的元素数量作为标准判断（可能存在误差）</p><p>这种方式如果保存大量用户 id ，会比较麻烦。我们的目的是为了计数，而不是保存用户 id。</p><p>Hyperloglog：<strong>优点</strong></p><ul><li>占用的内存是固定的</li><li>例如，2^64 个不同的基数，只需要 12KB 内存</li></ul><p>Redis 中所有和 hyperloglog 相关的命令都是以 pf 开头</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建第一组元素</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfadd mykey a b c d e f g h i j<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token comment"># 统计 mykey 中的基数</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfcount mykey<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfadd mykey2 a a b c d<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfcount mykey2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span><span class="token comment"># 合并 mykey 和 mykey2 生成 mykey3，mykey3 中无重复元素</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfmerge mykey3 mykey mykey2OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"mykey"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"mykey3"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"mykey2"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> pfcount mykey3<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果匀速容错，一定可以使用 hyperloglog</p><p>如果不允许容错，可以使用 set 或者自定义一种数据类型</p><h3 id="3、bitmaps"><a href="#3、bitmaps" class="headerlink" title="3、bitmaps"></a>3、bitmaps</h3><blockquote><p>位存储</p></blockquote><p>每一位用户用 0 或 1 表示</p><p>统计用户信息：活跃、不活跃，登录、未登录</p><p>打卡，一年365天，每一天都有两个状态</p><p>bitmaps：位图，也是一种数据结构，操作二进制位来进行记录，0 和 1 两种状态</p><blockquote><p>测试</p></blockquote><p>例如：使用 bitmaps 记录一星期的打卡</p><p>周一：1 周二：0</p><p>统计的时候只需要统计有多少个 1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">2</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">3</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">5</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit sign <span class="token number">6</span> <span class="token number">0</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看某一天是否有打卡</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> getbit sign <span class="token number">3</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> getbit sign <span class="token number">6</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>统计打卡天数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bitcount key start end<span class="token comment"># 默认的 bitcount key 统计所有值为 1 的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>MySQL：ACID</p><p>要么同时成功，要么同时失败：原子性</p><p>Redis 事务的本质：一组命令的集合！一个事务所有命令都会被序列化，在事务执行过程中，会按照顺序执行</p><ul><li>一次性</li><li>顺序性</li><li>排他性（不允许被其他命令干扰）</li></ul><p>Redis <strong>单条命令可以保证原子性</strong>，但是 <strong>Redis 中事务不保证原子性</strong></p><ul><li>Redis 事务没有隔离级别的概念（多条事务对同一资源进行操作的时候）</li><li>所有命令在事务并没有直接被执行，只有发起执行命令才会执行：Exec</li></ul><p>Redis 的事务：</p><ul><li>开启事务（<strong>multi</strong>）</li><li>命令入队（…）</li><li>执行事务（<strong>exec</strong>）</li></ul><p>锁：Redis 可以实现乐观锁</p><h3 id="1、正常执行事务"><a href="#1、正常执行事务" class="headerlink" title="1、正常执行事务"></a>1、正常执行事务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启事务</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multiOK<span class="token comment"># 命令入队</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k1 v1QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k2 v2QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> get k2QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k3 v3QUEUED<span class="token comment"># 执行事务</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span><span class="token number">1</span><span class="token punctuation">)</span> OK<span class="token number">2</span><span class="token punctuation">)</span> OK<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"v2"</span><span class="token number">4</span><span class="token punctuation">)</span> OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、放弃事务"><a href="#2、放弃事务" class="headerlink" title="2、放弃事务"></a>2、放弃事务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启事务</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multiOK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k1 v1QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k2 v2QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k4 v4QUEUED<span class="token comment"># 取消事务</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> discardOK<span class="token comment"># 事务队列中的命令都不会被执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、事务中的异常"><a href="#3、事务中的异常" class="headerlink" title="3、事务中的异常"></a>3、事务中的异常</h3><blockquote><p>编译型异常（代码问题，命令有错），事务中所有的命令都不会被执行</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multiOK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k1 v1QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k2 v2QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k3 v3QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> getset k3<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments <span class="token keyword">for</span> <span class="token string">'getset'</span> <span class="token builtin class-name">command</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k4 v4QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k5 v5QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> EXECABORT Transaction discarded because of previous errors.<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k5<span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k1<span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>运行时异常，如果事务队列中存在语法错误，那么执行的时候，其他命令可以正常执行</p></blockquote><p>单条命令是原子性的，但是事务中的命令队列不保证原子性和隔离性</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 <span class="token string">"v1"</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multiOK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> incr k1QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k2 v2QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k3 v3QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> get k3QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer or out of range <span class="token comment"># 虽然第一条命令错误，但是其他命令依旧执行成功了</span><span class="token number">2</span><span class="token punctuation">)</span> OK<span class="token number">3</span><span class="token punctuation">)</span> OK<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v3"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k2<span class="token string">"v2"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k3<span class="token string">"v3"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、监控-Watch-实现乐观锁"><a href="#4、监控-Watch-实现乐观锁" class="headerlink" title="4、监控 Watch 实现乐观锁"></a>4、<strong>监控 Watch 实现乐观锁</strong></h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会加锁！在更新数据时判断以下，在此期间是否有人修改过这个数据（MySQL 中使用 version 字段）</li><li>获取 version</li><li>更新的时候比较 version</li></ul><p>Redis 中实现乐观锁使用 Watch</p><blockquote><p>Redis 监控测试</p></blockquote><p>正常执行成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> money <span class="token number">100</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> out <span class="token number">0</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">watch</span> money  <span class="token comment"># 监视 money</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multi  <span class="token comment"># 事务正常结束，此期间数据没有发生变动，这个时候正常执行</span>OK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> decrby money <span class="token number">20</span>QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> incrby out <span class="token number">20</span>QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">80</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个线程对同一资源进行操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 一条线程开启监控，同时启动事务</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">watch</span> moneyOK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multiOK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> decrby money <span class="token number">10</span>QUEUED<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> incrby out <span class="token number">10</span>QUEUED<span class="token comment"># 由于监控到 money 变化，所以该事务不会成功</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span><span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span class="token comment"># 在 exec 之前另一条线程改变了被监视的资源</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get money<span class="token string">"80"</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> money <span class="token number">1000</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试多线程修改值，使用 wathc 可以当作 redis 的乐观锁操作。</strong></p><p>执行事务失败后如果想重新进行事务操作，就需要接触监视后重新监视新的数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> unwatchOK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">watch</span> moneyOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用 Java 操作 Redis</p><blockquote><p>什么是 Jedis</p></blockquote><p>Jedis 是 Redis 官方推荐的 Java 连接开发工具，相当于 Redis 的中间件</p><p>导入 jedis 的依赖包，可以去找最新版本</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 使用 fastjson 存储一些数据 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.76<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、SpringBoot-整合"><a href="#七、SpringBoot-整合" class="headerlink" title="七、SpringBoot 整合"></a>七、SpringBoot 整合</h2><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis</p><p><strong>SpringData</strong> 也是一个和 SpringBoot 齐名的项目</p><p><strong>说明：在 SpringBoot 2.x 后，原来使用的 Jedis 被替换为 <code>lettuce</code></strong></p><p>jedis: 采用的是直连，如果多个线程操作，是不安全的，如果想要避免不安全的操作，需要使用 jedis pool 连接池。更像 <strong>BIO 模式</strong></p><p>lettuce:  底层采用 netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数量，更像 <strong>NIO 模式</strong></p><h3 id="1、回顾-springboot-配置"><a href="#1、回顾-springboot-配置" class="headerlink" title="1、回顾 springboot 配置"></a>1、回顾 springboot 配置</h3><ul><li>springboot 所有的配置类，都有一个自动配置类</li><li>自动配置类都会绑定一个 properties 配置文件</li><li>查看的方法：<ul><li>第一步：找到 springboot 的配置 jar <code>org.springframework.boot:spring-boot-autoconfigure</code></li><li>第二步：找到 META-INFO 下面的 <code>spring.factories</code></li><li>第三步：搜索 Redis，找到 对应的自动配置类 <code>RedisAutoConfiguration</code></li><li>第四步：找到绑定的配置文件类：<code>@EnableConfigurationProperties(RedisProperties.class)</code></li><li>第五步：找到配置类绑定的前缀：<code>@ConfigurationProperties(prefix = "spring.redis")</code></li></ul></li></ul><h3 id="2、分析-RedisAutoConfiguration"><a href="#2、分析-RedisAutoConfiguration" class="headerlink" title="2、分析 RedisAutoConfiguration"></a>2、分析 RedisAutoConfiguration</h3><p>分析 <strong>RedisAutoConfiguration</strong> 类</p><p>其中注册了两个 Bean：</p><ul><li><code>RedisTemplate</code></li><li><code>StringRedisTemplate</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token class-name">RedisOperations</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">// 绑定配置属性类</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">RedisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">LettuceConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">JedisConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Bean</span>  <span class="token comment">// 当名为 redisTemplate 的 bean 不存在时，RedisTemplate 生效</span>  <span class="token comment">// 意思就是如果我们自己写了一个 redisTemplate，就使用我们的</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"redisTemplate"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 默认的 RedisTemplate, 没有过多的设置，redis 对象都是需要序列化的 (涉及到 NIO)</span>    <span class="token comment">// 两个泛型都是 Object，所以后面使用的时候都需要强制类型转换</span><span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> template<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// 多加一个 StringRedisTemplate 是为了方便</span>  <span class="token comment">// 上面那个适用于多种数据类型</span>  <span class="token comment">// 下面这个只适用 String 类型</span><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token annotation punctuation">@ConditionalOnSingleCandidate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span> <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">StringRedisTemplate</span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> template<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、自定义-RedisTemplate"><a href="#3、自定义-RedisTemplate" class="headerlink" title="3、自定义 RedisTemplate"></a>3、自定义 RedisTemplate</h3><ul><li><p>导入依赖</p></li><li><p>配置连接</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># redis 配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>服务器 IP<span class="token punctuation">}</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>如果有密码需要填写<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试</p></li></ul><blockquote><p>总结</p></blockquote><p>由于使用 RedisTemplate 执行各种命令时必须进行序列化和反序列化的操作，所以我们会发现，在 Java 程序中可以直接根据自定义的 key 拿到值，但是在服务器端 Redis 数据库中存储的却是一些无法识别的字符，两种方法解决这个问题：</p><ul><li><p>使用 <code>StringRedisTemplate</code>，但是它只能针对 String 做一些处理，非常不方便</p></li><li><p>更改 RedisTemplate 默认的序列化方式（默认使用的是）</p><pre class="line-numbers language-none"><code class="language-none">By default, it uses Java serialization for its objects (through {@link JdkSerializationRedisSerializer}.For String intensive operations consider the dedicated {@link StringRedisTemplate}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说默认序列化方式是 jdk 的序列化，针对 String 类型可以使用特定的 StringRedisTemplate</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// RedisTemplate 序列化要求</span><span class="token keyword">private</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">RedisSerializer</span> keySerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">RedisSerializer</span> valueSerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">RedisSerializer</span> hashKeySerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">RedisSerializer</span> hashValueSerializer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 默认的序列化方式</span><span class="token comment">// JDK 序列化会让字符转义</span><span class="token comment">// 我们需要使用 json 序列化</span>defaultSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdkSerializationRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token comment">// 解决思路</span><span class="token comment">// 自己定义一个 RedisTemplate</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>自定义 <code>RedisTemplate</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>naivekyo<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">JsonAutoDetect</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span></span><span class="token class-name">ObjectMapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>jsontype<span class="token punctuation">.</span>impl<span class="token punctuation">.</span></span><span class="token class-name">LaissezFaireSubTypeValidator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span></span><span class="token class-name">RedisConnectionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span></span><span class="token class-name">StringRedisSerializer</span><span class="token punctuation">;</span><span class="token comment">/** * @author naivekyo * @date 2021/6/27 *  * Redis 配置类 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 序列化配置</span>        <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ObjectMapper</span> objectMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objectMapper<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        objectMapper<span class="token punctuation">.</span><span class="token function">activateDefaultTyping</span><span class="token punctuation">(</span><span class="token class-name">LaissezFaireSubTypeValidator</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span> <span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>objectMapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// String 的序列化</span>        <span class="token class-name">StringRedisSerializer</span> stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 配置具体的序列化方式</span>        <span class="token comment">// key 采用 String 的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hash 的 key 也采用 String 的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// value 序列化方式采用 jackson</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// hash 的 value 序列化方式采用 jackson</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">/* TODO 缓存配置 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用自定义的 <code>RedisTemplate</code> 由于有多个 RedisTemplate 所以引入的时候可以指定 bean 名称</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"redisTemplate"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4、Redis-工具类"><a href="#4、Redis-工具类" class="headerlink" title="4、Redis 工具类"></a>4、Redis 工具类</h3><p>使用封装好的 RedisUtils</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>naivekyo<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>istack<span class="token punctuation">.</span>internal<span class="token punctuation">.</span></span><span class="token class-name">NotNull</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisTemplate</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">CollectionUtils</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Collection</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token comment">/** * @author naivekyo * @date 2021/6/27 *  * Redis 工具类 */</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RedisUtils</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>        <span class="token comment">// ================================= common ===============================</span>    <span class="token comment">/**     * 指定缓存失效时间     * @param key 键     * @param time 时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">expire</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 根据 key 获取过期时间     * @param key 键 不能为 null     * @return 时间(秒), 返回 0 代表永久有效     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">getExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 判断 key 是否存在     * @param key 键     * @return true 存在; false 不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasKey</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 根据 key 删除缓存     * @param key 可以传入一个或多个      */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">arrayToList</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment">// ================================ String ====================================</span>    <span class="token comment">/**     * 普通缓存获取     * @param key 键     * @return 值     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">/**     * 普通缓存放入     * @param key 键     * @param value 值     * @return true 成功; false 失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 普通缓存放入并设置时间     * @param key 键     * @param value 值     * @param time 时间(秒) time 要大于 0，如果 time 小于 0，将设置无限期     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 递增     * @param key   键     * @param delta 要增加几(大于0)     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">incr</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"递增因子必须大于0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 递减     * @param key   键     * @param delta 要减少几(小于0)     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">decr</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"递减因子必须大于0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span>delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// ============================= Map =================================</span>    <span class="token comment">/**     * HashGet     * @param key  键 不能为null     * @param item 项 不能为null     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">hget</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 获取 hashKey 对应的所有键值     * @param key 键     * @return 对应的多个键值     */</span>    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">hmget</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * HashSet     * @param key 键     * @param map 对应多个键值     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hmset</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * HashSet 并设置时间     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hmset</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 向一张 hash 表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hset</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 向一张 hash 表中放入数据,如果不存在将创建, 并设置过期时间     *     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hset</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 删除 hash 表中的值     *     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hdel</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 判断 hash 表中是否有该项的值     *     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hHasKey</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * hash 递增 如果不存在,就会创建一个 并把新增后的值返回     *     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">hincr</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">,</span> <span class="token keyword">double</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> by<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * hash 递减     *     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">hdecr</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> item<span class="token punctuation">,</span> <span class="token keyword">double</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> <span class="token operator">-</span>by<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// ==================================== Set =========================================</span>    <span class="token comment">/**     * 根据 key 获取 Set 中的所有值     * @param key 键     */</span>    <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">sGet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 根据 value 从一个 set 中查询,是否存在     *     * @param key   键     * @param value 值     * @return true 存在 false不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sHasKey</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将数据放入 set 缓存     *     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将 set 数据放入缓存, 并设置过期时间     *     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sSetAndTime</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Long</span> count <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 获取 set 缓存的长度     *     * @param key 键     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sGetSetSize</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 移除值为 value 的缓存     *     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">setRemove</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Long</span> count <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment">// ============================== List ==========================================</span>    <span class="token comment">/**     * 获取 list 缓存的内容     *     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1 代表所有值     */</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">lGet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span> <span class="token keyword">long</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 获取 list 缓存的长度     *     * @param key 键     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">lGetListSize</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 通过索引 获取 list 中的值     *     * @param key   键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">lGetIndex</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将 list 放入缓存     *     * @param key   键     * @param value 值     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将 list 放入缓存，并设置过期时间     * @param key   键     * @param value 值     * @param time  时间(秒)     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将 list 放入缓存     *     * @param key   键     * @param value 值     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将 list 放入缓存, 并设置过期时间     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 根据索引修改 list 中的某条数据     *     * @param key   键     * @param index 索引     * @param value 值     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lUpdateIndex</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> index<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 移除 N 个值为 value 的缓存     *     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">lRemove</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Long</span> remove <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> count<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> remove<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p><strong>通过 Java 操作 Redis 十分简单，更重要的是要去理解 Redis 的思想以及每一种数据结构的用处场景。</strong></p><p>关于对象的保存：</p><p>企业开发中所有的 pojo 类都必须实现 <code>Serializable</code> 接口，定义 <code>serialVersionUID</code></p><blockquote><p>objectMapper.enableDefaultTyping()  <strong>过时问题</strong></p></blockquote><p>查看 <code>ObjectMapper</code> 源码，推荐使用 <code>activateDefaultTyping()</code></p><p>博客：<a href="https://blog.csdn.net/zzhongcy/article/details/105813105">https://blog.csdn.net/zzhongcy/article/details/105813105</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Base settings contain defaults used for all {@link ObjectMapper} * instances. */</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">BaseSettings</span> DEFAULT_BASE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BaseSettings</span><span class="token punctuation">(</span>        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// cannot share global ClassIntrospector any more (2.5+)</span>        DEFAULT_ANNOTATION_INTROSPECTOR<span class="token punctuation">,</span>         <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">TypeFactory</span><span class="token punctuation">.</span><span class="token function">defaultInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">StdDateFormat</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>        <span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// to indicate "use Jackson default TimeZone" (UTC since Jackson 2.7)</span>        <span class="token class-name">Base64Variants</span><span class="token punctuation">.</span><span class="token function">getDefaultVariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment">// Only for 2.x; 3.x will use more restrictive default</span>        <span class="token class-name">LaissezFaireSubTypeValidator</span><span class="token punctuation">.</span>instance<span class="token punctuation">,</span>        <span class="token comment">// Since 2.12:</span>        <span class="token keyword">new</span> <span class="token class-name">DefaultAccessorNamingStrategy<span class="token punctuation">.</span>Provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、Redis-conf-详解"><a href="#八、Redis-conf-详解" class="headerlink" title="八、Redis.conf 详解"></a>八、Redis.conf 详解</h2><p>服务器端启动 Redis 服务需要指定它的配置文件</p><p>可以利用更改一些配置细节来优化速度</p><h3 id="1、单位"><a href="#1、单位" class="headerlink" title="1、单位"></a>1、单位</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Redis configuration file example.</span><span class="token comment">#</span><span class="token comment"># Note that in order to read the configuration file, Redis must be</span><span class="token comment"># started with the file path as first argument:</span><span class="token comment">#</span><span class="token comment"># ./redis-server /path/to/redis.conf</span><span class="token comment"># Note on units: when memory size is needed, it is possible to specify</span><span class="token comment"># it in the usual form of 1k 5GB 4M and so forth:</span><span class="token comment">#</span><span class="token comment"># 1k =&gt; 1000 bytes</span><span class="token comment"># 1kb =&gt; 1024 bytes</span><span class="token comment"># 1m =&gt; 1000000 bytes</span><span class="token comment"># 1mb =&gt; 1024*1024 bytes</span><span class="token comment"># 1g =&gt; 1000000000 bytes</span><span class="token comment"># 1gb =&gt; 1024*1024*1024 bytes</span><span class="token comment">#</span><span class="token comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、配置文件 unit 单位对大小写不敏感</p><h3 id="2、包含"><a href="#2、包含" class="headerlink" title="2、包含"></a>2、包含</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">################################## INCLUDES ###################################</span><span class="token comment"># Include one or more other config files here.  This is useful if you</span><span class="token comment"># have a standard template that goes to all Redis servers but also need</span><span class="token comment"># to customize a few per-server settings.  Include files can include</span><span class="token comment"># other files, so use this wisely.</span><span class="token comment">#</span><span class="token comment"># Note that option "include" won't be rewritten by command "CONFIG REWRITE"</span><span class="token comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><span class="token comment"># line as value of a configuration directive, you'd better put includes</span><span class="token comment"># at the beginning of this file to avoid overwriting config change at runtime.</span><span class="token comment">#</span><span class="token comment"># If instead you are interested in using includes to override configuration</span><span class="token comment"># options, it is better to use include as the last line.</span><span class="token comment">#</span><span class="token comment"># include /path/to/local.conf</span><span class="token comment"># include /path/to/other.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis 的配置文件可以不止一个，但是有一个主要的配置文件，它可以引入其他配置文件。</p><h3 id="3、模块"><a href="#3、模块" class="headerlink" title="3、模块"></a>3、模块</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">################################## MODULES #####################################</span><span class="token comment"># Load modules at startup. If the server is not able to load modules</span><span class="token comment"># it will abort. It is possible to use multiple loadmodule directives.</span><span class="token comment">#</span><span class="token comment"># loadmodule /path/to/my_module.so</span><span class="token comment"># loadmodule /path/to/other_module.so</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、网络"><a href="#4、网络" class="headerlink" title="4、网络"></a>4、网络</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Redis 绑定监听端口, 不要开放允许所有 IP 连接 Redis 服务器</span><span class="token comment"># 默认监听本地 IP, 只允许本机连接</span><span class="token builtin class-name">bind</span> <span class="token number">127.0</span>.0.1 -::1<span class="token comment"># Redis 的保护模式</span><span class="token comment"># 如果开启了保护模式, 但是没有指定监听一组 IP, 且开启密码, 那么 Redis 只允许本机客户端连接</span><span class="token comment"># 保护模式默认是开启的, 想关闭它时, 必须确认要从其他客户端连接 Redis 服务器且使用 bind 命令监听指定 IP 的访问请求。</span>protected-mode no<span class="token comment"># Redis 默认监听端口 6379, 如果指定监听端口 0, 那么 Redis 将不会监听 TCP 连接</span>port <span class="token number">6379</span><span class="token comment"># 剩下的就是一些超市配置和 ssl 认证, 暂时只做了解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、通用"><a href="#5、通用" class="headerlink" title="5、通用"></a>5、通用</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 是否以守护进程方式开启 Redis 服务</span><span class="token comment"># yes 则会在 /var/run/redis.pid 创建一个 pid 文件, Redis 会在后台运行(推荐使用)</span><span class="token comment"># 默认是 no</span>daemonize <span class="token function">yes</span><span class="token comment"># 如果 Redis 进程被 upstart 或者 systemd 命令监控, 则 daemonize 配置无效</span><span class="token comment"># 默认不开启</span>supervised no<span class="token comment"># pid 文件位置</span>pidfile /var/run/redis_6379.pid<span class="token comment"># 日志级别</span><span class="token comment"># Specify the server verbosity level.</span><span class="token comment"># This can be one of:</span><span class="token comment"># debug (a lot of information, useful for development/testing)</span><span class="token comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="token comment"># notice (moderately verbose, what you want in production probably)</span><span class="token comment"># warning (only very important / critical messages are logged)</span>loglevel notice<span class="token comment"># 日志文件</span><span class="token comment"># Specify the log file name. Also the empty string can be used to force</span><span class="token comment"># Redis to log on the standard output. Note that if you use standard</span><span class="token comment"># output for logging but daemonize, logs will be sent to /dev/null</span>logfile <span class="token string">""</span> <span class="token comment"># 日志的文件位置名，为空代表标准输出</span><span class="token comment"># 默认数据库数量</span><span class="token comment"># Set the number of databases. The default database is DB 0, you can select</span><span class="token comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><span class="token comment"># dbid is a number between 0 and 'databases'-1</span>databases <span class="token number">16</span><span class="token comment"># 是否显示 Redis 的启动 logo</span>always-show-logo no<span class="token comment"># 修改进程的标题, no 表示修改</span><span class="token comment"># By default, Redis modifies the process title (as seen in 'top' and 'ps') to</span><span class="token comment"># provide some runtime information. It is possible to disable this and leave</span><span class="token comment"># the process name as executed by setting the following to no.</span>set-proc-title <span class="token function">yes</span><span class="token comment"># 如果要修改进程标题</span><span class="token comment"># When changing the process title, Redis uses the following template to construct</span><span class="token comment"># the modified title.</span><span class="token comment">#</span><span class="token comment"># Template variables are specified in curly brackets. The following variables are</span><span class="token comment"># supported:</span><span class="token comment">#</span><span class="token comment"># {title}           Name of process as executed if parent, or type of child process.</span><span class="token comment"># {listen-addr}     Bind address or '*' followed by TCP or TLS port listening on, or</span><span class="token comment">#                   Unix socket if only that's available.</span><span class="token comment"># {server-mode}     Special mode, i.e. "[sentinel]" or "[cluster]".</span><span class="token comment"># {port}            TCP port listening on, or 0.</span><span class="token comment"># {tls-port}        TLS port listening on, or 0.</span><span class="token comment"># {unixsocket}      Unix domain socket listening on, or "".</span><span class="token comment"># {config-file}     Name of configuration file used.</span><span class="token comment">#</span>proc-title-template <span class="token string">"{title} {listen-addr} {server-mode}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、快照"><a href="#6、快照" class="headerlink" title="6、快照"></a>6、快照</h3><p><strong>涉及到持久化</strong></p><p>在规定的时间内，执行了多少操作，就会持久化到一个文件 <code>.rbd、.aof</code></p><p>Redis 是内存数据库，如果没有持久化，存储的数据就会断电即失</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># You can set these explicitly by uncommenting the three following lines.</span><span class="token comment">#</span><span class="token comment"># save 3600 1 # 如果一小时内，有一个 key 被修改，就进行持久化操作</span><span class="token comment"># save 300 100 # 300 秒内，100 个 key 被修改，就进行持久化操作</span><span class="token comment"># save 60 10000 # 60 秒内，。。。。。</span><span class="token comment"># 之后会设置自定义持久化机制</span><span class="token comment"># 如果持久化出现错误后，是否继续执行持久化操作，默认继续</span>stop-writes-on-bgsave-error <span class="token function">yes</span><span class="token comment"># 是否压缩 rdb 文件，默认开启，需要消耗 CPU 资源</span>rdbcompression <span class="token function">yes</span><span class="token comment"># 保存 rdb 文件时是否校验 rbd 文件，如果出错可以通过校验修复</span>rdbchecksum <span class="token function">yes</span><span class="token comment"># rdb 文件生成目录，默认当前目录</span><span class="token function">dir</span> ./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、复制"><a href="#7、复制" class="headerlink" title="7、复制"></a>7、复制</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">涉及到主从复制<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8、安全"><a href="#8、安全" class="headerlink" title="8、安全"></a>8、安全</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 获取密码</span>config get requirepass<span class="token comment"># 设置密码：两种方式，配置文件和运行时配置</span>config get requirepass <span class="token string">"password"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>还有很多自己看</p><h3 id="9、客户端"><a href="#9、客户端" class="headerlink" title="9、客户端"></a>9、客户端</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 设置能连接上 Redis 的最大客户端的数量</span>maxclients <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="10、内存管理"><a href="#10、内存管理" class="headerlink" title="10、内存管理"></a>10、内存管理</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># redis 配置最大的内存容量</span>maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">&gt;</span><span class="token comment"># 内存达到上限后的处理策略</span>maxmemory-policy noeviction<span class="token comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><span class="token comment"># is reached. You can select one from the following behaviors:</span><span class="token comment">#</span><span class="token comment"># volatile-lru -&gt; 只对设置了过期时间的 key 进行 LRU (默认值)</span><span class="token comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><span class="token comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><span class="token comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><span class="token comment"># volatile-random -&gt; Remove a random key having an expire set.</span><span class="token comment"># allkeys-random -&gt; Remove a random key, any key.</span><span class="token comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><span class="token comment"># noeviction -&gt; Don't evict anything, just return an error on write operations.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11、APPEND-ONLY-MODE（aof-配置）"><a href="#11、APPEND-ONLY-MODE（aof-配置）" class="headerlink" title="11、APPEND ONLY MODE（aof 配置）"></a>11、APPEND ONLY MODE（aof 配置）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认不开启，因为默认使用 rdb 方式持久化，在大部分情况下，rdb 完全够用</span>appendonly no<span class="token comment"># 持久化文件名</span>appendfilename <span class="token string">"appendonly.aof"</span><span class="token comment"># 同步机制</span><span class="token comment"># appendfsync always每次修改都会 sync，速度慢</span>appendfsync everysec <span class="token comment"># 每秒执行一次 sync，可能会丢失这一秒的数据</span><span class="token comment"># appendfsync no不执行 sync，这个时候操作系统自己同步数据，速度较快</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体配置看 持久化</p><h2 id="九、Redis-持久化"><a href="#九、Redis-持久化" class="headerlink" title="九、Redis 持久化"></a>九、Redis 持久化</h2><p>aof rdb 两种持久化方式</p><p>Redis 是缓存数据库，如果不能及时将内存中的数据保存到磁盘上面，一旦服务器进程退出，Redis 数据库中的所有状态都会消失，所以 Redis 提供了持久化功能</p><h3 id="1、RDB"><a href="#1、RDB" class="headerlink" title="1、RDB"></a>1、RDB</h3><p>Redis DataBase</p><p>指定时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘，即 Snapshot 快照，它恢复时直接将快照文件读入到内存中。</p><p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的，这就确保的极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么 RDB 方式要比 AOF 方式更加高效。RDB 的缺点是最后一次持久化后的数据可能丢失（情况：最后一次持久化的时候，服务器宕机了）。</p><p>一般情况下默认就是 RDB。</p><p>rdb 保存的文件：<code>dump.rdb</code>，该文件名是在配置文件中配置的</p><p>配置文件，设置 <code>save 60 5</code></p><p>测试：删除 dump.rdb，清空数据，进入命令行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先 save 生成 dump.rdb</span>save<span class="token comment"># 一分钟内设置 5 个 key，触发持久化机制</span><span class="token comment"># 关闭 redis 服务</span><span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>触发机制</p></blockquote><p>1、客户端向 Redis 服务器发送 save 或者 bgsave 命令就会让服务器生成 rdb 文件</p><ul><li><p>save 命令是一个同步操作</p><ul><li>当客户端向服务器发送 save 命令请求进行持久化时，服务器会阻塞 save 命令之后的其他客户端的请求，直到数据同步完成。如果数据量太大，同步数据会执行很久，而这期间 Redis 服务器也无法接收其他请求，所以，最好不要在生产环境使用 save 命令。</li></ul></li><li><p>bgsave 是一个异步操作</p><ul><li>当客户端发服务发出 bgsave 命令时，Redis 服务器主进程会 forks 一个子进程来数据同步问题，在将数据保存到 rdb 文件之后，子进程会退出。</li><li>所以，与 save 命令相比，Redis 服务器在处理 bgsave 采用子线程进行 IO 写入，而主进程仍然可以接收其他请求，但 forks 子进程是同步的，所以 forks 子进程时，一样不能接收其他请求，这意味着，如果forks一个子进程花费的时间太久(一般是很快的)，bgsave 命令仍然有阻塞其他客户的请求的情况发生。</li></ul></li></ul><p>2、Redis 配置文件中定义了触发机制</p><ul><li>这种通过服务器配置文件触发RDB的方式，与 bgsave 命令类似，达到触发条件时，会 forks 一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</li></ul><p>3、执行了 flushall 命令，也会触发 rdb 规则</p><p>4、退出 redis，也会产生 rdb 文件</p><p>触发了以上机制后，Redis 先生成临时 rdb 文件，并写入数据，完成数据写入后，就会用临时文件替代正式的 rdb 文件，最后删除原来的 rdb 文件。</p><blockquote><p>如何恢复 rdb 文件</p></blockquote><p>1、只需要将 rdb 文件放到 redis 启动目录下，redis 启动时会自动检查 dump.rdb ，然后恢复其中的数据</p><p>2、查看 rdb 文件存放的位置</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> config get <span class="token function">dir</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"dir"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"/opt/redis-6.2.4/bin"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点</p></blockquote><p>优点：</p><ol><li>适合大规模的数据恢复</li><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备份，由于使用子进程生成，所以对Redis服务器性能影响较小。</li><li>对数据的完整性要求不高</li></ol><p>缺点：</p><ol><li>不能完全保证数据完整性：如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用 save 命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用 bgsave 命令在 forks 子进程时，如果数据量太大，forks 的过程也会发生阻塞，另外，forks 子进程会耗费内存。</li></ol><h3 id="2、AOF"><a href="#2、AOF" class="headerlink" title="2、AOF"></a>2、AOF</h3><p>Append Only File</p><p>与 RDB 存储某个时刻的快照不同，AOF 持久化方式会记录客户端对<strong>服务器的每一次写操作命令</strong>，并将这些写操作以 Redis 协议追加保存到以后缀为 aof 文件末尾，在 Redis 服务器重启时，会加载并运行 aof 文件的命令，以达到恢复数据的目的。</p><ul><li>以日志形式记录每一个写操作，将 Redis 执行过的所有指令记录下来（读操作不记录）</li><li>只许追加文件但不可以改写文件，redis 启动之初会读取该文件重构数据</li></ul><p>Aof 保存的文件是：<code>appendonly.aof</code>  文件</p><p>aof 功能默认不开启，需要改配置文件，而且开启后默认每一秒中都同步一次</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 手动开启</span>appendonly <span class="token function">yes</span><span class="token comment"># 默认命名</span>appendfilename <span class="token string">"appendonly.aof"</span><span class="token comment"># 执行策略</span><span class="token comment"># appendfsync always</span>appendfsync everysec<span class="token comment"># appendfsync no</span><span class="token comment"># 默认不重写aof文件</span>no-appendfsync-on-rewrite no<span class="token comment"># 保存目录</span><span class="token function">dir</span> ~/redis/<span class="token comment"># 其余配置暂时默认即可 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>always</li></ol><p>客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</p><ol start="2"><li>everysec</li></ol><p>appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。</p><ol start="3"><li>no</li></ol><p>Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</p><p>两种重写方式：</p><p>通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用。</p><p>客户端向服务器发送bgrewriteaof命令，也可以让服务器进行AOF重写。</p><p>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理</p><p>重写aof文件的好处</p><ul><li>压缩 aof 文件，减少磁盘占用量。</li><li>将 aof 的命令压缩为最小命令集，加快了数据恢复的速度。</li></ul><p>重启 redis 自动生成 appendonly.aof</p><p>会发现在启动目录下存在这两个文件：</p><ul><li>appendonly.aof</li><li>redis-check-aof</li></ul><p>当 aof 文件出错时，可以利用后者去校验恢复数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果 appendonly.aof 出错，那么就无法启动 Redis</span><span class="token comment"># 利用 redis-check-aof 修复 appendonly.aof</span>redis-check-aof --fix appendonly.aof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>优缺点</p></blockquote><p>优点：</p><ol><li>每一次修改都同步，很好的保证了数据的完整性</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步时，效率最高</li><li>AOF 只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li></ol><p>缺点：</p><ol><li>相对于数据文件的大小，aof 远远大于 rdb，修复的速度比 rdb 慢</li><li>aof 运行效率比 rdb 慢，所以 redis 默认配置是 rdb</li></ol><p>如果 aof 文件大于 64MB，就会 forks 一个新的进程，将文件进行重写</p><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>在主从复制中，rdb 就是备用的，放在从机上面，aof 几乎不使用</p><table><thead><tr><th align="center">方式</th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">启动优先级</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">体积</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">恢复速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">数据安全性</td><td align="center">会丢数据</td><td align="center">由策略决定</td></tr><tr><td align="center">轻重</td><td align="center">重</td><td align="center">轻</td></tr></tbody></table><p>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</p><blockquote><p>扩展</p></blockquote><ol><li>RDB 持久化方式是在指定时间间隔内对数据进行快照存储</li><li>AOF 持久化记录每次对数据库写的操作，当服务器重启的时候来重新执行这些命令恢复原始数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾，Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大</li><li><strong>只做缓存，可以不使用任何持久化</strong></li><li>同时开启两种持久化：<ul><li>这种情况下，Redis 重启优先载入 AOF 文件恢复数据，因为通常情况下 AOF 文件保存的数据要比 RDB 更加完整</li><li>RDB 保存数据不实时，同时使用两者时服务器重启也只会找 AOF 文件，那么要不要使用 AOF 呢？建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），快速重启，而且不会有 AOF 潜在的 bug</li></ul></li><li>性能建议<ul><li>RDB 文件只做备份，建议只在 Slave 上持久化 RDB 文件，而且只要 15 分钟备份一次就好了，只保留 <code>save 900 1</code> 这条规则</li><li>如果 Enable AOF，好处在于最恶劣情况下也只会丢失不超过 2 秒的数据，启动脚本只需要 load 自己的 AOF 文件就可以了，代价：一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上，默认超过原大小 100% 大小重写可以改到适当的数值</li><li>如果不 Enable AOF，仅靠 Master-Slave Replication 实现高可用性也可以，能省掉一大笔 IO，也减少了 rewrite 时带来的系统波动。代价是如果 Master/Slave 同时宕机（最恶劣情况：断电），会丢失十几分钟的数据，启动脚本也需要比较两个 Maseter/Slave 中的 RDB 文件，载入较新的那个，微博就是这种架构</li></ul></li></ol><h2 id="十、Redis-发布订阅"><a href="#十、Redis-发布订阅" class="headerlink" title="十、Redis 发布订阅"></a>十、Redis 发布订阅</h2><p>Redsi 发布订阅（pub/sub）是一种<strong>消息通信模式</strong>：发送者（pub）发送消息，订阅者（sub）接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><h3 id="1、简单模型"><a href="#1、简单模型" class="headerlink" title="1、简单模型"></a>1、简单模型</h3><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/redis-pub-sub.png"></p><p>重点：</p><ul><li>消息发送者</li><li>频道</li><li>消息订阅者</li></ul><h3 id="2、相关命令"><a href="#2、相关命令" class="headerlink" title="2、相关命令"></a>2、相关命令</h3><blockquote><p>命令</p></blockquote><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室（chatroom）和实时广播、实时提醒</p><ul><li>psubscribe pattern [pattern…]   <ul><li>订阅一个或多个符合给定模式的频道</li></ul></li><li>pubsub subcommand [argument [argument …]]<ul><li>查看订阅与发布系统状态</li></ul></li><li>publish channel message<ul><li>将消息发送到指定的频道</li></ul></li><li>punsubscribe [pattern [pattern …]]<ul><li>退订所有给定模式的频道</li></ul></li><li>subscribe channle [channel …]<ul><li>订阅给定的一个或多个频道的信息</li></ul></li><li>ubsubscribe [channel [channel …]]<ul><li>退订给定的频道</li></ul></li></ul><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 订阅一个频道</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PSUBSCRIBE naivekyichannelReading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"psubscribe"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"naivekyichannel"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token comment"># 消息发送者发布消息</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBLISH naivekyichannel <span class="token string">"hello naivekyo"</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBLISH naivekyichannel <span class="token string">"hello redis"</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token comment"># 频道将消息发布给所有订阅者</span>Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"pmessage"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"naivekyichannel"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"naivekyichannel"</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"hello naivekyo"</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"pmessage"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"naivekyichannel"</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"naivekyichannel"</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"hello redis"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h3><p>Redis 是用 C 编写的，可以分析源码（pubsub.c），了解发布和订阅机制的底层实现，加深对 Redis 的理解</p><p>Redis 通过 PUBLISH、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能</p><p>通过 SUBSCRIBE 命令订阅某个频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p><p>通过 PUBLIC 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的及时聊天，群聊等功能。</p><p>使用场景：</p><ol><li>实时消息系统</li><li>实时聊天（频道当作聊天室， 将信息回显给所有人）</li><li>订阅、关注系统</li></ol><p>复杂的场景：会使用 消息中间件（MQ，Kafka）</p><h2 id="十一、Redis-主从复制"><a href="#十一、Redis-主从复制" class="headerlink" title="十一、Redis 主从复制"></a>十一、Redis 主从复制</h2><p>服务器高可用：主从复制、哨兵模式</p><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>主从复制，指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器上。前者称为 主节点（master/leader），后者称为从节点（slave/follower）；<strong>数据的复制是单向的</strong>。Master 以写为主，Slave 以读为主。</p><p><strong>默认情况下，每台 Redis 服务器都是主节点</strong>；</p><p>且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据备份方式</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应该连接主节点，读 Redis 数据时应该连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li><strong>高可用（集群）基石</strong>：除了上述作用外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础</li></ol><p>一般来说，要将 Redis 用于工程项目中，只是用一台 Redis 是万万不能的（可能会宕机，一般配三台），原因如下：</p><ol><li>从结构上，单个 Redis 服务器会发送单点故障，并且一台服务器需要处理所有的请求负载，压力过大。</li><li>从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作 Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G</li></ol><p>电商网站上的商品，一般都是一次上次，无数次浏览的，说专业点就是 ”多读少写“</p><p>对于这样的场景，我们使用如下架构：</p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/write%26read.png"></p><p>主从复制、读写分离 解决大量读操作的场景，减缓服务器压力，架构中经常使用。一般：<strong>一主二从</strong>（后续哨兵模式会选举，所以最低需要三台）</p><h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><p>只配置从库，不用配置主库！（Redis 默认启动就是主库）</p><p>因为现在只有一台服务器，所以要配置的是单机多集群</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看当前库的信息</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> info replication<span class="token comment"># Replication</span>role:master               <span class="token comment"># 角色为主机</span>connected_slaves:0<span class="token comment"># 没有附属从机</span>master_failover_state:no-failovermaster_replid:e53a0801b50a28ab552c9e8575b8ead398c0a650master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>准备工作：</p><ul><li><p>一台服务器开四个连接 session</p></li><li><p>一主二从 + 一个测试</p></li><li><p>配置文件需要准备四个</p></li><li><p>先关闭 Redis 服务</p></li><li><p>修改配置文件（因为在一台服务器上开多个 Redis 进程，所以需要修改诸多配置）</p><ul><li>端口</li><li>pid 文件</li><li>生成日志的文件名 </li><li>dump 的文件名</li></ul></li></ul><h3 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h3><p>分别开启 一主二从 及测试 Redis 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@naivekyo bin<span class="token punctuation">]</span><span class="token comment"># ps aux | grep redis</span>root     <span class="token number">31183</span>  <span class="token number">0.1</span>  <span class="token number">0.5</span> <span class="token number">162508</span>  <span class="token number">9956</span> ?        Rsl  <span class="token number">14</span>:29   <span class="token number">0</span>:00 redis-server *:6379root     <span class="token number">31238</span>  <span class="token number">0.0</span>  <span class="token number">0.5</span> <span class="token number">162504</span>  <span class="token number">9884</span> ?        Rsl  <span class="token number">14</span>:29   <span class="token number">0</span>:00 redis-server *:6380root     <span class="token number">31280</span>  <span class="token number">0.0</span>  <span class="token number">0.5</span> <span class="token number">162504</span>  <span class="token number">9884</span> ?        Rsl  <span class="token number">14</span>:30   <span class="token number">0</span>:00 redis-server *:6381root     <span class="token number">31314</span>  <span class="token number">0.0</span>  <span class="token number">0.5</span> <span class="token number">162504</span>  <span class="token number">9872</span> ?        Ssl  <span class="token number">14</span>:30   <span class="token number">0</span>:00 redis-server *:6382root     <span class="token number">31326</span>  <span class="token number">0.0</span>  <span class="token number">0.0</span> <span class="token number">112812</span>   <span class="token number">964</span> pts/3    R+   <span class="token number">14</span>:30   <span class="token number">0</span>:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、一主二从"><a href="#4、一主二从" class="headerlink" title="4、一主二从"></a>4、一主二从</h3><p><strong>默认情况下，每一台 Redis 服务器都是主节点</strong>；</p><p>一般情况下，只需要配置从机就可以了。</p><ul><li><p>主要方法是为从机指定要给 主机</p></li><li><p>例如我们现在测试用的 一主（6379）二从（6380、6381）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 主机不用管</span><span class="token comment"># 从机使用</span>slaveof <span class="token function">host</span> port <span class="token comment"># 指定主机为 host.port 的 Redis 进程</span><span class="token comment"># 主机检测状态</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> info replication<span class="token comment"># Replication</span>role:masterconnected_slaves:2slave0:ip<span class="token operator">=</span><span class="token number">127.0</span>.0.1,port<span class="token operator">=</span><span class="token number">6380</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">84</span>,lag<span class="token operator">=</span><span class="token number">0</span>slave1:ip<span class="token operator">=</span><span class="token number">127.0</span>.0.1,port<span class="token operator">=</span><span class="token number">6381</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">84</span>,lag<span class="token operator">=</span><span class="token number">0</span>master_failover_state:no-failovermaster_replid:76474c9a04098ec797bb5fe681943e15f0923f5dmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:84second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:84<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果出现 master 机 使用 info replication 显示连接状态为 down，可能是因为设置了 <strong>requirepassword</strong> 但是没有设置 <strong>masterauth</strong>，为了方便，建议两个密码设置一样</p></li></ul><p>真实的主从配置应该在配置文件中配置，这样才是永久的，如果使用命令配置就是暂时的。</p><h3 id="5、配置文件"><a href="#5、配置文件" class="headerlink" title="5、配置文件"></a>5、配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置主机 ip</span>replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span><span class="token comment"># 。。。。。。。。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>细节</p></blockquote><p><strong>主机可以写，从机不能写只能读</strong></p><p>主机中所有信息和数据都会自动被从机保存</p><ul><li>在没有配置哨兵的情况下，如果主机宕机了，从机就找不到主机了，但是它依旧保留着主机的信息，如果主机恢复了，从机依旧可以获取到主机写入的数据。</li><li>而当从机宕机了，主机依旧在写入数据，当从机恢复上线后，依旧会获取到主机这段时间写入的数据</li></ul><h3 id="6、复制原理"><a href="#6、复制原理" class="headerlink" title="6、复制原理"></a>6、复制原理</h3><p>Slave 启动成功连接到 master 后会发送一个 sync 同步命令</p><p>Master 接收到命令，会启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，master 将传送这个文件给 slave，并完成一次完全同步。</p><ul><li>全量复制：slave 服务接收到数据库文件数据后，将其存盘并加载到内存中</li><li>增量复制：master 继续将新的所有收集到的修改命令依次传给 slave，完成同步</li></ul><p>但是只要是重新连接到 master，一次完全同步（全量复制）就会被自动执行。</p><p>考虑这种情况：</p><ul><li><p>原有模式  S - M - S</p></li><li><p>改变模式 M - S M - S</p></li><li><p>后一种情况，将从机设置为主机，但是查看信息它依旧是 从机，所以它还是只能读不能写，这时候情况发生了变化，主机写入的信息被从机读取，从机作为另一台从机的主机，又会将数据传递给另一台从机</p></li></ul><p>这<strong>一种模型</strong>：</p><ul><li>可以完成主从复制</li><li>当真正的 Master 宕机后，同时兼具 Master 和 Salve 身份的从机可以使用命令 <code>SLAVEOF no one</code>，将自己的省份变为 master，这样它的下面还是有从机的，如果真正的主机恢复上线了，就没有从机了，除非再次使用命令配置</li></ul><p><strong>SLAVEOF no one</strong> 适合任何模型</p><h3 id="7、哨兵模式（自动选举）"><a href="#7、哨兵模式（自动选举）" class="headerlink" title="7、哨兵模式（自动选举）"></a>7、<strong>哨兵模式</strong>（自动选举）</h3><p>当主机宕机后，从机中自动选举出新的主机</p><blockquote><p>概述</p></blockquote><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间服务不可用。这不是一种推荐的方式，更多时候，推荐优先使用哨兵模式。</p><p>Redis 从 2.8 开始正式提供了 Sentinel（哨兵）架构来解决这个问题。</p><p>能够在后台监控主机是否故障，如果故障了就<strong>根据投票数自动将从库转换为主库。</strong></p><p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行。其原理是 <strong>哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例</strong></p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/Sentinel.png"></p><p>这里的哨兵有两个作用：</p><ul><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵检测到 master 宕机，会自动将 slave 切换为 master，然后通过 <strong>发布订阅模式</strong> 通知其他的从服务器，修改配置文件，让它们切换主机</li></ul><p>然后一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。</p><h3 id="8、多哨兵模式"><a href="#8、多哨兵模式" class="headerlink" title="8、多哨兵模式"></a>8、多哨兵模式</h3><p>哨兵除了监控各个 Redis 服务器，各个哨兵之间也进行相互监控。</p><p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是 哨兵1 主观的认为主服务器不可用，这个现象称为 <strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵（随机）发起，进行 failover[故障转移] 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 <strong>客观下线</strong>。</p><blockquote><p>测试</p></blockquote><p>目前的状态是一主二从。</p><p><strong>修改哨兵配置文件：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 指定监控对象</span><span class="token comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>sentinel monitor myredis <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span> <span class="token comment"># 数字 1，代表只有当 1 个以上的哨兵认为主机出现了故障，那么就可以判定主机客观下线，开始从从机中选举主机</span>sentinel down-after-milliseconds mymaster <span class="token number">60000</span>sentinel failover-timeout mymaster <span class="token number">180000</span>sentinel parallel-syncs mymaster <span class="token number">1</span>sentinel monitor resque <span class="token number">192.168</span>.1.3 <span class="token number">6380</span> <span class="token number">4</span>sentinel down-after-milliseconds resque <span class="token number">10000</span>sentinel failover-timeout resque <span class="token number">180000</span>sentinel parallel-syncs resque <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动哨兵：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-sentinel <span class="token punctuation">..</span>/etc/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 Master 节点断开了，Sentinel 会根据投票算法选出新的主机</p><p>而主机如果恢复上线，它会成为新的主机的从机</p><h3 id="9、哨兵模式优点和缺点"><a href="#9、哨兵模式优点和缺点" class="headerlink" title="9、哨兵模式优点和缺点"></a>9、哨兵模式优点和缺点</h3><p>优点：</p><ol><li>哨兵集群，基于主从复制模式，所有主从配置优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性会更好</li><li>哨兵模式就是主从模式的升级，更加健壮</li></ol><p>缺点：</p><ol><li>Redis 不好在线扩容，集群容量一旦达到上线，在线扩容就非常麻烦</li><li>实现哨兵模式的配置其实是非常麻烦的，里面有很多选择</li></ol><blockquote><p>哨兵模式的配置文件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 哨兵实例运行端口，默认 26379</span>port <span class="token number">26379</span><span class="token comment"># 哨兵 sentinel 的工作目录</span><span class="token function">dir</span> /tmp<span class="token comment"># 哨兵 sentinel 监控的 redis 主节点 </span><span class="token comment"># quorum 配置多少个 sentinel 哨兵同一认为 master 主节点失联，那么这时就客观认为主节点失联了</span><span class="token comment"># sentinel mointer &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>sentinel monitor mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">2</span><span class="token comment"># 当在 Redis 实例中开启了 requirepass foobared 授权密码，这样所有连接 Redis 实例的客户端都要提供密码</span><span class="token comment"># 设置哨兵 sentinel 连接主从的密码，注意必须为主从设置一样的密码</span><span class="token comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>sentinel auth-pass mymaster <span class="token number">123456</span><span class="token comment"># 指定多少毫秒之后，主节点没有应答哨兵 sentinel，此时，哨兵主观认为主节点下线，默认 30 秒</span><span class="token comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel down-after-milliseconds <span class="token number">30000</span><span class="token comment"># 这个配置项指定了在发生 failover 主备切换时最多可以有多少个 slave 同时对新的 master 进行同步</span><span class="token comment"># 这个数字越小，完成 failover 所需的时间最长</span><span class="token comment"># 但是这个数字越大，意味着越多的 slave 因为 replication 而不可用</span><span class="token comment"># 可以通过将这个值设置为 1 来保证每次只有一个 slave 处于不能处理命令请求的状态</span><span class="token comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>sentinel parallel-syncs mymaster <span class="token number">1</span><span class="token comment"># 故障转移的超时时间 failover-timeout 可以用在以下方面</span><span class="token comment"># 1. 同一个 sentinel 对同一个 master 两次 failover 之间的时间间隔</span><span class="token comment"># 2. 当一个 slave 从一个错误的 master 那里同步数据开始计算时间。直到 slave 被纠正为向正确的 master 那里同步数据时。</span><span class="token comment"># 3. 当想要取消一个正在进行的 failover 所需要的时间</span><span class="token comment"># 4. 当进行 failover 时，配置所有 slaves 指向新的 master 所需的最大时间。不过，即使查过了这个时间，slaves 依然会被正确配置为指向 master，但是就不按 parallel-syncs 所配置的规则来了</span><span class="token comment"># 默认三分钟</span><span class="token comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel failover-timeout mymaster <span class="token number">180000</span><span class="token comment"># SCRIPTS EXECUTIOn</span><span class="token comment"># 配置当某一事件发生时所需要指向的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时可以发邮件通知相关人员</span><span class="token comment"># 对于脚本的执行结果有以下预测</span><span class="token comment"># 若脚本执行后返回 1，那么该脚本稍后将会被再次执行，重复次数目前默认为 0</span><span class="token comment"># 若脚本执行后返回 2，或者比 2 更高的一个返回值，脚本将不会重复执行</span><span class="token comment"># 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值 1 时的行为相同</span><span class="token comment"># 一个脚本的最大执行时间为 60s，如果超过这个时间，脚本将会被一个 SIGKILL 信号终止，之后重新执行</span><span class="token comment"># 通知型脚本：当 sentinel 有任何警告级别的时间发生时（比如说 redis 实例的主观失效和客观失效等等），将会去调用这个脚本，这时一个脚本应该通过邮件，SMS 等方式通知系统管理员关于系统不正常运行的信息，调用该脚本时，传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果 sentinel.conf 配置文件配置了这个脚本路径，那么必须保证这个脚本存在于这个路径中，并且是可执行的，否则 sentinel 无法正常启动</span><span class="token comment"># 通知脚本</span><span class="token comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>sentinel notification-script mymaster /var/redis/notify.sh<span class="token comment"># 客户端重新配置主节点参数脚本</span><span class="token comment"># 当一个 master 由于 failover 而发生改变时，这个脚本将会调用，通知相关的客户端关于 master 地址已经发生改变的信息</span><span class="token comment"># 以下参数将会在调用脚本时传给脚本：</span><span class="token comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><span class="token comment"># 目前 &lt;state&gt; 总是 "failover"</span><span class="token comment"># &lt;role&gt; 是 "leader" 或者 "observer" 中的一个</span><span class="token comment"># 参数 from-ip from-port to-ip to-port 是用来和旧的 master 和 新的 master(及旧的 slave) 通信的</span><span class="token comment"># 这个脚本应该是通用的，能够被多次调用，不是针对性的</span><span class="token comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十二、Redis-缓存穿透和雪崩（面试高频，工作常用）"><a href="#十二、Redis-缓存穿透和雪崩（面试高频，工作常用）" class="headerlink" title="十二、Redis 缓存穿透和雪崩（面试高频，工作常用）"></a>十二、Redis <strong>缓存穿透和雪崩</strong>（面试高频，工作常用）</h2><p>服务的高可用问题</p><p>Redis 缓存的使用，极大提升了应用程序的性能和效率，特别是数据查询方面，但同时，它也带来了一些问题，其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解，如果对数据的一致性要求很高，那么就不要使用缓存。</p><p>另外一些典型的问题就是：缓存穿透、缓存雪崩和缓存击穿。目前，业界也有比较流行的解决方案。</p><h3 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h3><blockquote><p>概念</p></blockquote><p>缓存穿透的概念比较简单，用户想要查询一个数据，发现 redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（比如说：秒杀场景），于是都去请求持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><p>流程：</p><ul><li>先到 Redis 查询数据：没有查到</li><li>再去 持久层数据库中查询：也没有查到</li><li>最终返回结果：没有查询到</li><li>可能用户会反复请求查询，结果每次都查不到，这就对数据库造成了很大的压力</li><li><strong>缓存穿透</strong></li></ul><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合就丢弃，从而避免了对底层存储系统的查询压力：</p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/bloomFilter.png"></p><p><strong>缓存空对象</strong></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据库将会直接从缓存中获取，保护了后端数据源；</p><p>但是这个方法会存在两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空指的键</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致（如果这个值存储层有了，但是缓存层还是存的空值），这对于需要保持一致性的业务会有影响</li></ol><h3 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h3><p>微博热点</p><blockquote><p>概述</p></blockquote><p>注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热门，客户端不停的请求这个 key，并发量非常高，大并发集中对这个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般都是热点数据，由于缓存过期，会同时访问数据库来查询最新的数据，并且回写缓存，会导致数据库瞬间压力过大</p><blockquote><p>解决方法</p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题</p><p><strong>加互斥锁</strong></p><p>分布式锁：可以使用分布式锁，保证对每个 key 同时只有一个线程去查询后台服务，其他线程没有获得分布式锁的权限，因此只需等待即可。这种方式讲高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h3 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机</p><p>产生雪崩的原因之一，比如说双十一 11 点的时候将一批商品的信息写入缓存，设置过期时间为 1 小时，到了 12 点正好过期，这时候大量对这批商品信息的查询访问请求都落到了数据库头上，对于数据库而言，会产生周期性的压力波峰。于是所有请求都会到达存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p>其中过期，并不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非是对数据库产生周期性的压力而已。而缓存服务器节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间把数据库压垮。</p><p>例子：双十一时，淘宝可以停掉一部分服务，保证主要服务可用</p><blockquote><p>解决方案</p></blockquote><p><strong>Redis 高可能</strong></p><p>这个思想的含义是，既然 redis 有可能挂掉，那我多设置几台 Redis，一台挂掉后其他的还可以继续工作，其实就是采用 Redis 集群。（异地多活）</p><p><strong>限流降级</strong></p><p>这个解决方案的思路是：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Database </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAop-AspectJ-Intro</title>
      <link href="/2021/07/07/springaop-aspectj-intro/"/>
      <url>/2021/07/07/springaop-aspectj-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="AspectJ-在-Spring-Aop-中的体现"><a href="#AspectJ-在-Spring-Aop-中的体现" class="headerlink" title="AspectJ 在 Spring Aop 中的体现"></a>AspectJ 在 Spring Aop 中的体现</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Aop 即面向切面编程，项目中，例如 日志、权限等穿插整个项目但并不是核心逻辑的，我们可以把它单独提出来作为一个单独的模块管理。</p><h2 id="二、AspectJ-AOP"><a href="#二、AspectJ-AOP" class="headerlink" title="二、AspectJ-AOP"></a>二、AspectJ-AOP</h2><p>AOP在 Java 中的 Spring 中已经有了，可以直接在 idea 中新建一个 Aspect，注意关键字为 aspect(MyAspectJDemo.aj,其中aj为AspectJ的后缀)，含义与 class 相同，即定义一个 AspectJ 的类。AspectJ 是一个 java 实现的 AOP 框架，它能够对 java代码进行 AOP 编译（一般在编译期进行），让 java 代码具有AspectJ 的 AOP 功能（当然需要特殊的编译器），可以这样说 AspectJ 是目前实现 AOP 框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ 与 java 程序完全兼容，几乎是无缝关联。</p><p>创建 AspectJ 文件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义main文件</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWord</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> sayHello<span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">HelloWord</span> hello<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HelloWord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义切面</span><span class="token keyword">public</span> aspect <span class="token class-name">MyAspectJDemo</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 定义切点,日志记录切点     */</span>    pointcut <span class="token function">recordLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token class-name">HelloWord</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义切点,权限验证(实际开发中日志和权限一般会放在不同的切面中,这里仅为方便演示)     */</span>    pointcut <span class="token function">authCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token class-name">HelloWord</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义前置通知!     */</span>    <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">authCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sayHello方法执行前验证权限"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 定义后置通知     */</span>    <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">recordLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sayHello方法执行后记录日志"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用aspect关键字定义了一个类，这个类就是一个切面，它可以是单独的日志切面(功能)，也可以是权限切面或者其他，在切面内部使用了pointcut定义了两个切点，一个用于权限验证，一个用于日志记录，而所谓的切点就是那些需要应用切面的方法，如需要在sayHello方法执行前后进行权限验证和日志记录，那么就需要捕捉该方法，而pointcut就是定义这些需要捕捉的方法（常常是不止一个方法的），这些方法也称为目标方法，最后还定义了两个通知，通知就是那些需要在目标方法前后执行的函数，如before()即前置通知在目标方法之前执行，即在sayHello()方法执行前进行权限验证，另一个是after()即后置通知，在sayHello()之后执行，如进行日志记录。到这里也就可以确定，切面就是切点和通知的组合体，组成一个单独的结构供后续使用。这里一般日志和权限都是要单独定义切面的，这里示例不规范。 对于结构表达式</p><p><code>pointcut authCheck():call(* HelloWord.sayHello(..))</code></p><p>关键字为pointcut，定义切点，后面跟着函数名称，最后编写匹配表达式，此时函数一般使用 call() 或者execution() 进行匹配，这里我们统一使用call()</p><p><code>pointcut 函数名 : 匹配表达式</code></p><p>recordLog()是函数名称，自定义的，*表示任意返回值，接着就是需要拦截的目标函数，sayHello(..)的..，表示任意参数类型。这里理解即可，后面Spring AOP会有关于切点表达式的分析，整行代码的意思是使用pointcut定义一个名为recordLog的切点函数，其需要拦截的(切入)的目标方法是HelloWord类下的sayHello方法，参数不限</p><p><code>before():authCheck(){ System.out.println("something"); }</code></p><ul><li><p>before这个处于函数名之前的方法成为通知方法，共有5种通知方法</p></li><li><p>before 目标方法执行前执行，前置通知</p></li><li><p>after 目标方法执行后执行，后置通知</p></li><li><p>after returning 目标方法返回时执行 ，后置返回通知</p></li><li><p>after throwing 目标方法抛出异常时执行 异常通知</p></li><li><p>around 在目标函数执行中执行，可控制目标函数是否执行，甚至可以拿到方法执行后的返回值，环绕通知</p></li></ul><h2 id="三、Spring-中的-Aop"><a href="#三、Spring-中的-Aop" class="headerlink" title="三、Spring 中的 Aop"></a>三、Spring 中的 Aop</h2><p>Spring AOP 与 ApectJ 的目的一致，都是为了统一处理横切业务，但与 AspectJ 不同的是，Spring AOP 并不尝试提供完整的 AOP 功能(即使它完全可以实现)，Spring AOP 更注重的是与 Spring IOC 容器的结合，并结合该优势来解决横切业务的问题，因此在 AOP 的功能完善方面，相对来说 AspectJ 具有更大的优势。</p><p>同时，Spring 注意到 AspectJ 在 AOP 的实现方式上依赖于特殊编译器 (ajc编译器)，因此 Spring 很机智回避了这点，转向采用动态代理技术的实现原理来构建 Spring AOP 的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。在 AspectJ 1.5 后，引入 @Aspect 形式的注解风格的开发，Spring 也非常快地跟进了这种方式，因此 Spring 2.0 后便使用了与 AspectJ 一样的注解。</p><p>请注意，Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器。下面我们先通过一个简单的案例来演示Spring的AOP使用</p><p>spring 的 aop 中使用了一些表达式用于处理切点：</p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions</a></p><h3 id="1、Aop-Concepts"><a href="#1、Aop-Concepts" class="headerlink" title="1、Aop Concepts"></a>1、Aop Concepts</h3><ul><li><p>Aspect：切面一般都是横跨多个类（或多个业务模块），例如项目中企业项目开发中事务管理就是一个应用 aop 的非常好的例子。</p><p>而在 Java 项目中配置切面有两种方式：xml 文件配置或者 使用了 <code>@Aspect</code> 注解的类</p></li><li><p>Join point：在 spring 中一个连接点就代表一个要被执行的方法</p></li><li><p>Advice：通知就是当 切面 中的切点被执行后采取的行动。通知大致分为三种：around、before、after</p></li><li><p>Pointcut：切入点和连接点是相匹配的，当某个连接点被切入点表达式匹配到时，就会在这个连接点上执行通知（advice）：在 spring aop 理念中，由切入点表达式匹配连接点是它的核心。Spring 默认使用的是 AspectJ 的切入点表达式</p></li><li><p>Introduction：介绍：spring aop 允许你为 advised object 定义一个新的接口（提供对应的实现类），在 AspectJ 社区中这被称为 类型间声明</p></li><li><p>Target Object：目标对象相当于 spring aop 在运行时通过代理为切面生成一个代理对象</p></li><li><p>Aop Proxy：spring aop 采用 JDK 提供的动态代理或者 CGLIB 代理</p></li><li><p>Weaving：编制：将切面和对应的模块联系起来（一般在编译时期）</p></li></ul><h3 id="2、Advice-的类型"><a href="#2、Advice-的类型" class="headerlink" title="2、Advice 的类型"></a>2、Advice 的类型</h3><ul><li><p>before 目标方法执行前执行，前置通知</p></li><li><p>after 目标方法执行后执行，后置通知</p></li><li><p>after returning 目标方法返回时执行 ，后置返回通知</p></li><li><p>after throwing 目标方法抛出异常时执行 异常通知</p></li><li><p>around 在目标函数执行中执行，可控制目标函数是否执行，甚至可以拿到方法执行后的返回值，环绕通知</p></li></ul><h3 id="3、Proxy-类型"><a href="#3、Proxy-类型" class="headerlink" title="3、Proxy 类型"></a>3、Proxy 类型</h3><p>默认使用 JDK 动态代理</p><p>建议使用 CGLIB</p><h3 id="4、使用-AspectJ"><a href="#4、使用-AspectJ" class="headerlink" title="4、使用 @AspectJ"></a>4、使用 @AspectJ</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj</a></p><p>注意：</p><ul><li>切面类可能不会被 spring 扫描到，因此<ul><li>要么自定义 config 配置，注册 bean</li><li>要么 aspect 类上加上 <code>@Component</code></li><li>或者在主启动类上自定义扫描规则</li></ul></li><li>切点支持的表达式语法有好几种，用的比较多的是 <code>execution</code></li></ul><h3 id="5、使用切入点表达式"><a href="#5、使用切入点表达式" class="headerlink" title="5、使用切入点表达式"></a>5、使用切入点表达式</h3><p>常规切入点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 如果连接点执行后抛出异常，就执行这个 * @param e*/</span><span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>  value <span class="token operator">=</span> <span class="token string">"execution(* com.naivekyo.controller.AopTestController.addUser(..))"</span><span class="token punctuation">,</span>  throwing <span class="token operator">=</span> <span class="token string">"e"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterThrowable</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出现异常： msg = "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用和 AspectJ 类似的切入点，而且可以考虑结合多种表达式</p><p>连接方式：<code>&amp;&amp;、||、|</code></p><p>`</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(public * *(..))"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">anyPublicOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"within(com.xyz.myapp.trading..*)"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inTrading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"anyPublicOperation() &amp;&amp; inTrading()"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">tradingOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>anyPublicOperation：匹配所有 public 方法</li><li>inTrading：如果在这个交易模块中执行了匹配的方法，就执行这个切入点</li><li>tradingOperation：前两者的结合，执行了匹配方法且方法为 public</li></ul><p><mark>顺带一提，可见性并没有太大影响，因为是通过动态代理拿到的</mark></p><h3 id="6、常用的-expression-表达式"><a href="#6、常用的-expression-表达式" class="headerlink" title="6、常用的 expression 表达式"></a>6、常用的 expression 表达式</h3><p>大部分开发者更喜欢用 <code>execution</code> 来指定切入点表达式</p><ul><li><p>匹配所有公共方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">execution</span><span class="token punctuation">(</span><span class="token keyword">public</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行所有名词以 set 开头的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> set<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行 AccountService 下的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>AccountService</span><span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行 service 包下定义的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span>*<span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行 service 包及其子包总定义的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">execution</span><span class="token punctuation">(</span><span class="token operator">*</span> com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token punctuation">.</span>*<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>只在 Spring AOP 中指定 service 包中定义的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">within</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span>*<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>只在 Spring AOP 中执行 service 包及其子包总定义的所有方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">within</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>仅在 Spring AOP 中代理执行 AccountService 接口中所有连接点方法</p><p>this 更适合用于绑定形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>AccountService</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>仅在 Spring AOP 中使用目标对象代理执行 AccountService 接口中的所有方法</p><p>target 更适合用于绑定形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span>AccountService</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>仅在 Spring AOP 中执行：仅有一个参数，且运行时传递的为 <code>Serializable</code> 类型</p><p>args 更适合用于绑定形式</p><p>注意 args 匹配的是运行时参数，它和 <code>execution(* *(java.io.Serializable))</code> 是不同的，后者匹配的是方法签名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">args</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>仅在 Spring AOP 中执行，匹配带有 <code>@Transactinal</code> 注解的类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@target</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>Transactional</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>任何连接点(仅在Spring AOP中执行方法)，其中目标对象的声明类型具有@Transactional注释:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@within</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>Transactional</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>任何连接点(仅在Spring AOP中执行方法)，其中执行方法具有@Transactional注释:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@annotation</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span>Transactional</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>任何接受单个参数的连接点(仅在Spring AOP中执行方法)，其中传递的参数的运行时类型有@Classified注释:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@args</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>xyz<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span>Classified</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>(仅在Spring AOP中执行方法)指定 bean 的名字为 tradeService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">bean</span><span class="token punctuation">(</span>tradeService<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Spring bean上的任何连接点(仅在Spring AOP中执行方法)的名称与通配符表达式*Service:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">bean</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">Service</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="7、写出更好的-Pointcuts"><a href="#7、写出更好的-Pointcuts" class="headerlink" title="7、写出更好的 Pointcuts"></a>7、写出更好的 Pointcuts</h3><ul><li><p>类指示符选择一种特定的连接点: <code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, and <code>handler</code>.</p></li><li><p>作用域指示符选择一组感兴趣的连接点(可能是多种) <code>within</code> and <code>withincode</code></p></li><li><p>上下文指示符根据上下文匹配(或可选地绑定): <code>this</code>, <code>target</code>, and <code>@annotation</code></p></li></ul><p>一个编写良好的切入点至少应该包括前两种类型(类型和范围)。您可以包含上下文指示符，以便根据连接点上下文进行匹配，或者绑定该上下文以便在通知中使用。只提供一种指示符或仅仅</p><p>只提供 类型 或者只提供上下文 指示符可以工作，但可能会影响编织性能(使用的时间和内存)。</p><p>作用域指示符的匹配速度非常快，使用它们意味着AspectJ可以非常快地解散不应该进一步处理的连接点组。一个好的切入点应该尽可能包含一个作用域指示符。</p><h3 id="8、Advice-介绍"><a href="#8、Advice-介绍" class="headerlink" title="8、Advice 介绍"></a>8、Advice 介绍</h3><p>所有的通知方法都可以给它传递一个参数 <code>JoinPoint</code>，但是注意 Around advice 第一个参数是 <code>ProceedingJoinPoint</code> 它是 JoinPoint 的子类。</p><p><code>JoinPoint</code> 接口提供了一些有用的方法：</p><ul><li><code>getArgs()</code>: Returns the method arguments.</li><li><code>getThis()</code>: Returns the proxy object.</li><li><code>getTarget()</code>: Returns the target object.</li><li><code>getSignature()</code>: Returns a description of the method that is being advised.</li><li><code>toString()</code>: Prints a useful description of the method being advised.</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@After</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"execution(* com.naivekyo.controller.AopTestController.addUser(..))"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> point<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"最终通知..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取方法的参数</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 返回代理对象</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回目标对象</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回方法签名</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回有用的信息</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>给 Advice 传递参数</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 方式一</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validateAccount</span><span class="token punctuation">(</span><span class="token class-name">Account</span> account<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span class="token comment">// 方式二</span><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">accountDataAccessOperation</span><span class="token punctuation">(</span><span class="token class-name">Account</span> account<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"accountDataAccessOperation(account)"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validateAccount</span><span class="token punctuation">(</span><span class="token class-name">Account</span> account<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>See the AspectJ programming guide for more details.</p><blockquote><p>Advice 绑定注解</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 定义注解</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Auditable</span> <span class="token punctuation">{</span>    <span class="token class-name">AuditCode</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 绑定注解</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">audit</span><span class="token punctuation">(</span><span class="token class-name">Auditable</span> auditable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">AuditCode</span> code <span class="token operator">=</span> auditable<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Advcie 绑定泛型</p></blockquote><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj</a></p><p>比较复杂，看官网</p><blockquote><p>指定参数的名称</p></blockquote><p>利用 <code>argNames</code> 参数</p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj</a></p><blockquote><p>Advice 的优先级</p></blockquote><p>在同一个切面中不同切入点调用相同连接点：</p><ul><li>Before：优先级高的先调用</li><li>After：优先级高的后调用</li></ul><p>在不同切面的不同切入点调用相同连接点：</p><ul><li><p>除非自己指定，否则就不能确定执行顺序</p></li><li><p>指定执行顺序</p><ul><li>Aspect 类实现 <code>org.springframework.core.Ordered</code> 接口，重写 <strong>getOrder 方法</strong>，改方法返回 int 值即优先级，越小越高</li><li>或者Aspect 类使用 <code>@Order</code> 注解给定优先级，值越小优先级越大</li></ul></li></ul><p>本质上在一个切面中定义的所有切入点，它们对应的连接点应该是不同的，如果出现了对应相同连接点的情况，spring 5.2.7 之后，spring 给它们指定的顺序</p><p><code>@Around</code>, <code>@Before</code>, <code>@After</code>, <code>@AfterReturning</code>, <code>@AfterThrowing</code>.</p><p>需要注意的是 <code>@After</code> 依旧是最后调用的（优先级高的最后调）</p><h3 id="9、Introductions"><a href="#9、Introductions" class="headerlink" title="9、Introductions"></a>9、Introductions</h3><p>类型间声明一般适用于 父子类继承 或 实现接口这两种情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UsageTracking</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DeclareParents</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"com.xzy.myapp.service.*+"</span><span class="token punctuation">,</span> defaultImpl<span class="token operator">=</span><span class="token class-name">DefaultUsageTracked</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">UsageTracked</span> mixin<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recordUsage</span><span class="token punctuation">(</span><span class="token class-name">UsageTracked</span> usageTracked<span class="token punctuation">)</span> <span class="token punctuation">{</span>        usageTracked<span class="token punctuation">.</span><span class="token function">incrementUseCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 甚至可以通过编程方式访问</span><span class="token class-name">UsageTracked</span> usageTracked <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UsageTracked</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"myService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10、Aspect-Instantiation-Models"><a href="#10、Aspect-Instantiation-Models" class="headerlink" title="10、Aspect Instantiation Models"></a>10、Aspect Instantiation Models</h3><p>Aspect 实例化模型是 AOP 中比较高级的概念</p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj</a></p><h3 id="11、例子"><a href="#11、例子" class="headerlink" title="11、例子"></a>11、例子</h3><p>现在使用 aop 做一个例子：演示服务请求遇到死锁的情况，可以使用 aspect 很好的处理，不让客户看到 <code>PessimisticLockingFailureException </code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentOperationExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_MAX_RETRIES <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxRetries <span class="token operator">=</span> DEFAULT_MAX_RETRIES<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> order <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMaxRetries</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxRetries <span class="token operator">=</span> maxRetries<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>order<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>order <span class="token operator">=</span> order<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"com.xyz.myapp.CommonPointcuts.businessService()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doConcurrentOperation</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> numAttempts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">PessimisticLockingFailureException</span> lockFailureException<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            numAttempts<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">PessimisticLockingFailureException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lockFailureException <span class="token operator">=</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>numAttempts <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxRetries<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> lockFailureException<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里设置了最高优先级从而实现覆盖事务通知</p><p>而且 maxRetries 和 order 都可以使用 spring 注入（xml 或 @Value）</p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj</a></p><p>还可以做进一步加强，注重细节：针对特定注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Idempotent</span> <span class="token punctuation">{</span>    <span class="token comment">// marker annotation</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更改 Advice：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; "</span> <span class="token operator">+</span>        <span class="token string">"@annotation(com.xyz.myapp.service.Idempotent)"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doConcurrentOperation</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、Spring-AOP-APIs"><a href="#12、Spring-AOP-APIs" class="headerlink" title="12、Spring AOP APIs"></a>12、Spring AOP APIs</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-api">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-api</a></p><p>分析内部原理需要好好研究</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Aop </tag>
            
            <tag> AspectJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_Log_Intro</title>
      <link href="/2021/07/07/mysql-log-intro/"/>
      <url>/2021/07/07/mysql-log-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-日志学习"><a href="#MySQL-日志学习" class="headerlink" title="MySQL 日志学习"></a>MySQL 日志学习</h1><h2 id="一、日志分类"><a href="#一、日志分类" class="headerlink" title="一、日志分类"></a>一、日志分类</h2><p><strong>官方文档：</strong><a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">https://dev.mysql.com/doc/refman/8.0/en/binary-log.html</a></p><p>下面简单介绍 MySQL 中 4 种日志文件的作用。</p><ul><li>二进制日志：该日志文件会以二进制的形式记录数据库的各种操作，但不记录查询语句。</li><li>错误日志：该日志文件会记录 MySQL 服务器的启动、关闭和运行错误等信息。</li><li>通用查询日志：该日志记录 MySQL 服务器的启动和关闭信息、客户端的连接信息、更新、查询数据记录的 SQL 语句等。</li><li>慢查询日志：记录执行事件超过指定时间的操作，通过工具分析慢查询日志可以定位 MySQL 服务器性能瓶颈所在。</li></ul><h2 id="二、错误日志（Error-Log）"><a href="#二、错误日志（Error-Log）" class="headerlink" title="二、错误日志（Error Log）"></a>二、错误日志（Error Log）</h2><p>MySQL 默认开启错误日志，该日记主要记录 MySQL 服务器启动和停止过程中的信息、服务器在运行过程中发生的故障和异常情况等。</p><p>my.cnf  中的 <code>log_error=dir/{filename}</code> 配置错误日志的文件位置</p><p>在 MySQL 中，通过 SHOW 命令可以查看错误日志文件所在的目录及文件名信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show variables like <span class="token string">'log_error'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MySQL 中，可以使用 mysqladmin 命令来开启新的错误日志，以保证 MySQL 服务器上的硬盘空间。mysqladmin 命令的语法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin -u root -p flush-logs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行该命令后，MySQL 服务器首先会自动创建一个新的错误日志，然后将旧的错误日志更名为 filename.err-old。</p><p>MySQL 服务器发生异常时，管理员可以在错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。对于很久之前的错误日志，查看的可能性不大，可以直接将这些错误日志删除。</p><h2 id="三、二进制日志"><a href="#三、二进制日志" class="headerlink" title="三、二进制日志"></a>三、二进制日志</h2><h3 id="1、MySQL8-0-二进制日志"><a href="#1、MySQL8-0-二进制日志" class="headerlink" title="1、MySQL8.0 二进制日志"></a>1、MySQL8.0 二进制日志</h3><p>二进制日志（Binary Log）也可叫作变更日志（Update Log），是 MySQL 中非常重要的日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，不包含数据记录查询操作。</p><p>如果 MySQL 数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</p><p>默认情况下，二进制日志功能是关闭的。可以通过以下命令查看二进制日志是否开启，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show variables like <span class="token string">'log_bin'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>启动和关闭二进制日志</p></blockquote><p>在 MySQL 中，可以通过在配置文件中添加 log-bin 选项来开启二进制日志，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>log-bin<span class="token operator">=</span>dir/<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里注意：现在安装的是 mysql8.0 的 <code>mysql-community-server</code> 版本，<strong>默认是开启二进制日志的</strong>，且二进制日志一般放在 mysql 的 data 目录下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 现在是在这个位置</span>/var/lib/mysql/binlog.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>查看二进制日志文件列表：<code>show binary logs;</code></p></li><li><p>查看当前正在写入的二进制日志文件：<code>show master status;</code></p></li><li><p><strong>查看二进制文件内容：</strong></p><ul><li>二进制日志使用二进制格式存储，不能直接打开查看。如果需要查看二进制日志，必须使用 <code>mysqlbinlog </code>命令。</li><li>mysqlbinlog 命令的语法形式如下：<code>mysqlbinlog filename.number</code></li><li>mysqlbinlog 命令只在当前文件夹下查找指定的二进制日志，因此需要在二进制日志所在的目录下运行该命令，否则将会找不到指定的二进制日志文件。(使用 mysqlbinlog 命令时，可以指定二进制文件的存储路径)</li></ul></li><li><p>除了 filename.number 文件，MySQL 还会生成一个名为 filename.index 的文件，这个文件存储着所有二进制日志文件的列表，可以用记事本打开该文件。</p></li><li><p>删除二进制日志：二进制日志中记录着大量的信息，如果很长时间不清理二进制日志，将会浪费很多的磁盘空间。删除二进制日志的方法很多，下面介绍几种删除二进制日志的方法。</p><ul><li>使用 <code>RESET MASTER</code> 可以删除所有二进制日志</li><li>根据编号删除二进制日志：<code>PURGE MASTER LOGS TO 'filename.number';</code></li><li>根据创建时间删除二进制日志：<code>PURGE MASTER LOGS TO 'yyyy-mm-dd hh:MM:ss';</code>其中，“hh”为 24 制的小时。该语句将删除在指定时间之前创建的所有二进制日志。</li></ul></li><li><p>暂停二进制日志：在配置文件中设置了 log_bin 选项之后，MySQL 服务器将会一直开启二进制日志功能。删除该选项后就可以停止二进制日志功能，如果需要再次启动这个功能，需要重新添加 log_bin 选项。由于这样比较麻烦，所以 MySQL 提供了暂时停止二进制日志功能的语句。</p><p>如果用户不希望自己执行的某些 SQL 语句记录在二进制日志中，可以在执行这些 SQL 语句之前暂停二进制日志功能。</p><p>使用 SET 语句来暂停/开启二进制日志功能，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SET <span class="token assign-left variable">SQL_LOG_BIN</span><span class="token operator">=</span><span class="token number">0</span>/1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令中，0 表示暂停二进制日志功能，1 表示开启二进制功能。</p></li></ol><blockquote><p>扩展</p></blockquote><p>my.ini 中的 [mysqld] 组下面有几个设置参数是关于二进制日志的：</p><p>expire_logs_days = 10<br>max_binlog_size = 1​00M</p><ul><li>expire_logs_day 定义了 MySQL 清除过期日志的时间、二进制日志自动删除的天数。默认值为 0，表示“没有自动删除”。当 MySQL 启动或刷新二进制日志时可能删除。</li><li>max_binlog_size 定义了单个文件的大小限制，如果二进制日志写入的内容大小超出给定值，日志就会发生滚动（关闭当前文件，重新打开一个新的日志文件）。不能将该变量设置为大于 1GB 或小于 4096B（字节），其默认值是 1GB。</li></ul><blockquote><p>小技巧：实际工作中，二进制日志文件与数据库的数据文件不放在同一块硬盘上，这样即使数据文件所在的硬盘被破坏，也可以使用另一块硬盘上的二进制日志来恢复数据库文件。两块硬盘同时坏了的可能性要小得多，这样可以保证数据库中数据的安全。</p></blockquote><h3 id="2、MySQL-5-7-开启二进制日志"><a href="#2、MySQL-5-7-开启二进制日志" class="headerlink" title="2、MySQL 5.7 开启二进制日志"></a>2、MySQL 5.7 开启二进制日志</h3><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span><span class="token comment"># 启用二进制日志记录，8.0之前默认禁用，之后默认启用</span><span class="token comment"># 二进制日志文件名称前缀，二进制日志是具有基本名称和数字扩展名的文件序列。</span><span class="token comment"># 二进制日志文件的默认位置是数据目录，可以使用此选项设置</span><span class="token key attr-name">log-bin</span><span class="token punctuation">=</span><span class="token value attr-value">mysql-bin</span><span class="token comment"># 在MySQL 5.7中，启用二进制日志记录时必须指定服务器ID，否则服务器将无法启动</span><span class="token comment"># 在MySQL 8.0中，服务器ID默认设置为1</span><span class="token comment"># 默认值未0，如果使用默认值则不能和从节点通信，这个值的区间是：1到(2^32)-1</span><span class="token key attr-name">server-id</span><span class="token punctuation">=</span><span class="token value attr-value">1</span><span class="token comment"># 禁用MySQL服务器将二进制日志同步到磁盘的功能，有操作系统控制，性能最佳，安全性最差</span><span class="token comment"># sync_binlog=0</span><span class="token comment"># 在提交事务之前启用二进制日志到磁盘的同步，性能最差，安全性最佳</span><span class="token key attr-name">sync_binlog</span><span class="token punctuation">=</span><span class="token value attr-value">1</span><span class="token comment"># 日志在每次事务提交时写入并刷新到磁盘，安全性最佳</span><span class="token key attr-name">innodb_flush_log_at_trx_commit</span><span class="token punctuation">=</span><span class="token value attr-value">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、使用二进制日志还原数据库"><a href="#3、使用二进制日志还原数据库" class="headerlink" title="3、使用二进制日志还原数据库"></a>3、使用二进制日志还原数据库</h3><p>二进制日志中记录了用户对数据库更改的所有操作，如 INSERT 语句、UPDATE 语句、CREATE 语句等。如果数据库因为操作不当或其它原因丢失了数据，可以通过<strong>二进制日志来查看在一定时间段内用户的操作，结合数据库备份来还原数据库。</strong></p><p>数据库遭到意外损坏时，应该先使用最近的备份文件来还原数据库。另外备份之后，数据库可能进行了一些更新，这时可以使用二进制日志来还原。因为二进制日志中存储了更新数据库的语句，如 UPDATE 语句、INSERT 语句等。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 二进制日志还原数据库的命令如下：</span>mysqlbinlog filename.number <span class="token operator">|</span> mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上命令可以理解成，先使用 mysqlbinlog 命令来读取 filename.number 中的内容，再使用 mysql 命令将这些内容还原到数据库中。</p><p>技巧：二进制日志虽然可以用来还原 MySQL 数据库，但是其占用的磁盘空间也是非常大的。因此，在备份 MySQL 数据库之后，应该删除备份之前的二进制日志。如果备份之后发生异常，造成数据库的数据损失，可以通过备份之后的二进制日志进行还原。</p><p>使用 mysqlbinlog 命令进行还原操作时，必须是编号（number）小的先还原。例如，mylog.000001 必须在 mylog.000002 之前还原。</p><h2 id="四、MySQL-通用查询日志（General-Query-Log）"><a href="#四、MySQL-通用查询日志（General-Query-Log）" class="headerlink" title="四、MySQL 通用查询日志（General Query Log）"></a>四、MySQL 通用查询日志（General Query Log）</h2><p>通用查询日志（General Query Log）用来记录用户的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。</p><ul><li><p>查询通用查询日志是否开启</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show variables like <span class="token string">'%general%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MySQL 5.7 默认是关闭的，general_log_file 变量指定了通用查询日志文件所在的位置。</p></li><li><p>启动和设置通用查询日志</p><p>在 MySQL 中，可以通过在 MySQL 配置文件添加 log 选项来开启通用查询日志，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token assign-left variable">log</span><span class="token operator">=</span>dir/filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，dir 参数指定通用查询日志的存储路径；filename 参数指定日志的文件名。如果不指定存储路径，通用查询日志将默认存储到 MySQL 数据库的数据文件夹下。如果不指定文件名，默认文件名为 hostname.log，其中 hostname 表示主机名。</p></li><li><p>查看通用查询日志</p><p>如果希望了解用户最近的操作，可以查看通用查询日志。通用查询日志以文本文件的形式存储，可以使用普通文本文件查看该类型日志内容。</p></li><li><p>停止通用查询日志</p><p>通用查询日志启动后，可以通过两种方法停止该日志。一种是将 MySQL 配置文件中的相关配置注释掉，然后重启服务器，来停止通用查询日志。</p><p>上述方法需要重启 MySQL 服务器，这在某些场景，比如有业务量访问的情况下是不允许的，这时可以通过另一种方法来动态地控制通用查询日志的开启和关闭。</p><p>设置 MySQL 的环境变量 general_log 为关闭状态可以停止该日志，示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> global general_log <span class="token operator">=</span> off<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除通用查询日志</p><p>在 MySQL 中，可以使用 mysqladmin 命令来开启新的通用查询日志。新的通用查询日志会直接覆盖旧的查询日志，不需要再手动删除了。</p><p>mysqladmin 命令的语法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin -u root -p flush-logs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，如果希望备份旧的通用查询日志，必须先将旧的日志文件拷贝出来或者改名。然后，再执行 mysqladmin 命令。</p><p>除了上述方法之外，还可以手工删除通用查询日志。删除之后需要重新启动 MySQL 服务。重启之后就会生成新的通用查询日志。如果希望备份旧的日志文件，可以将旧的日志文件改名，然后重启 MySQL 服务。</p><p>由于通用查询日志会记录用户的所有操作，如果数据库的使用非常频繁，通用查询日志将会占用非常大的磁盘空间，对系统性能影响较大。一般情况下，数据管理员可以删除很长时间之前的通用查询日志或关闭此日志，以保证 MySQL 服务器上的硬盘空间。</p></li></ul><h2 id="五、MySQL-慢查询日志（Slow-Query-Log）"><a href="#五、MySQL-慢查询日志（Slow-Query-Log）" class="headerlink" title="五、MySQL 慢查询日志（Slow Query Log）"></a>五、MySQL 慢查询日志（Slow Query Log）</h2><p>慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。</p><p>通俗的说，MySQL 慢查询日志是排查问题的 SQL 语句，以及检查当前 MySQL 性能的一个重要功能。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>默认情况下，慢查询日志功能是关闭的。可以通过以下命令查看是否开启慢查询日志功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show variables like <span class="token string">'slow_query%'</span><span class="token punctuation">;</span>show variables like <span class="token string">'long_query_time'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数说明如下：</p><ul><li>slow_query_log：慢查询开启状态</li><li>slow_query_log_file：慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）</li><li>long_query_time：查询超过多少秒才记录</li></ul><blockquote><p>启动和设置慢查询日志</p></blockquote><p>可以通过 log-slow-queries 选项开启慢查询日志。通过 long_query_time 选项来设置时间值，时间以秒为单位。如果查询时间超过了这个时间值，这个查询语句将被记录到慢查询日志。</p><p>将 log_slow_queries 选项和 long_query_time 选项加入到配置文件的 [mysqld] 组中。格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>log-slow-queries<span class="token operator">=</span>dir<span class="token punctuation">\</span>filename<span class="token assign-left variable">long_query_time</span><span class="token operator">=</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li>dir 参数指定慢查询日志的存储路径，如果不指定存储路径，慢查询日志将默认存储到 MySQL 数据库的数据文件夹下。</li><li>filename 参数指定日志的文件名，生成日志文件的完整名称为 filename-slow.log。 如果不指定文件名，默认文件名为 hostname-slow.log，hostname 是 MySQL 服务器的主机名。</li><li>“n”参数是设定的时间值，该值的单位是秒。如果不设置 long_query_time 选项，默认时间为 10 秒。</li></ul><blockquote><p>查看慢查询日志</p></blockquote><p>如果你想查看哪些查询语句的执行效率低，可以从慢查询日志中获得信息。和错误日志、查询日志一样，慢查询日志也是以文本文件的形式存储的，可以使用普通的文本文件查看工具来查看。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#开启 MySQL 慢查询日志功能，并设置时间，命令和执行过程如下：</span><span class="token builtin class-name">set</span> global slow_query_log <span class="token operator">=</span> ON<span class="token punctuation">;</span><span class="token builtin class-name">set</span> global long_query_time <span class="token operator">=</span> <span class="token number">0.001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于需要演示这里我们将时间设置为了 0.001 秒，执行时间超过 0.001 秒的 SQL 语句将被记录到日志中。</p><blockquote><p>删除慢查询日志</p></blockquote><p>慢查询日志的删除方法与通用日志的删除方法是一样的。可以使用 mysqladmin 命令来删除。也可以使用手工方式来删除。mysqladmin 命令的语法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin -u root -p flush-logs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行该命令后，命令行会提示输入密码。输入正确密码后，将执行删除操作。新的慢查询日志会直接覆盖旧的查询日志，不需要再手动删除。</p><p>数据库管理员也可以手工删除慢查询日志，删除之后需要重新启动 MySQL 服务。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux_centos7_study</title>
      <link href="/2021/07/07/linux-centos7-study/"/>
      <url>/2021/07/07/linux-centos7-study/</url>
      
        <content type="html"><![CDATA[<h1 id="前言：Secure-CRT-连接出现过的问题"><a href="#前言：Secure-CRT-连接出现过的问题" class="headerlink" title="前言：Secure CRT 连接出现过的问题"></a>前言：Secure CRT 连接出现过的问题</h1><p>使用 Secure CRT 连接服务器，遇到的一些问题</p><blockquote><p>SecureCRT 连接慢的问题</p></blockquote><p>修改SecureCRT配置目录的Sessions子目录下对应的服务器ini配置文件， GSSAPI Method 设置的值为 none，重启SecureCRT。</p><blockquote><p>连接出现错误 The Semaphore timeout period has expired</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># vi /etc/ssh/sshd_config</span>GG到文件末尾，增加下面2行：ClientAliveInterval <span class="token number">60</span>ClientAliveCountMax <span class="token number">3</span><span class="token comment"># service sshd reload</span>然后就解决问题了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>vim 出现 xxx swap already exist 的问题</p></blockquote><p>这是由于使用 vim 时异常退出导致的问题</p><p>需要删除相应目录下的 <strong>.xxx.swap</strong> 临时文件就好了。</p><blockquote><p>关于有时候重启电脑后主机ping不通虚拟机的问题</p></blockquote><p>这个问题暂时没有明确的解决方法，虽然和虚拟机的相关服务每次开机都会自动启动，但还是无法 ping 虚拟机，可能是在某次开机启动项优化时将相关的服务停止了，现在可行的解决方法如下：</p><p><strong>禁用 VMnet8 然后重启</strong></p><h1 id="一、Linux-常用命令（CentOS-7）"><a href="#一、Linux-常用命令（CentOS-7）" class="headerlink" title="一、Linux 常用命令（CentOS 7）"></a>一、Linux 常用命令（CentOS 7）</h1><ol><li>ifconfig 和 ip addr  —— 查看 ip</li><li>yum install     —— 安装<ul><li>安装 ssh 服务 yum install openssh-server    </li><li>检查ssh服务，yum list install | grep openssh-server</li></ul></li><li>ps -e | grep    —— 查看进程</li><li>service network restart    —— 重启网络服务</li><li>init 0、init 6    —— 关机和重启</li><li>contOS7 开始默认使用 firewalld，它基于 iptables，有 iptables 的核心，但是 iptables 的服务没安装<ul><li>停止防火墙，并禁用 firewalld 服务：sudo systemctl stop firewalld.service</li><li>sudo systemctl disable firewalld.service</li><li>改用 iptables 服务：    sudo yum install iptables-services</li><li>检查状态    service iptables status</li></ul></li><li>开启sshd服务 <strong>systemctl restart sshd , systemctl status sshd</strong> 检查服务状态，或者输入<strong>netstat -an | grep 22</strong>  检查  <strong>22</strong> 号端口是否开启监听，或者 <strong>ps -e | grep sshd</strong></li><li>netstat 常用 ：监听 tcp、udp 端口监听情况 <strong>netstat -tunlp</strong></li><li>复制粘贴（Linux和windows通用） ctrl + insert 和 shift + insert</li><li>传文件，右键选择 connect SFTP Session，输入 put + 文件路径</li></ol><ul><li>pwd：服务器当前目录</li><li>lpwd：Windows当前目录</li><li>ls 和 lls 与上面类似</li><li>cd：改变服务器目录</li><li>lcd：改变本地目录</li><li>Windows向服务器传文件：put 目标文件</li><li>服务器向Windows传文件：get 目标文件</li></ul><ol start="11"><li>解压 tar zxvf 压缩包    压缩 tar zcvf 输出目标.tgz 文件，文件。。。<ul><li>Linux中其他类似命令：zip/unzip和gzip/gunzip等等</li></ul></li><li>正则表达式，最常用的 * ：匹配任意字符 ?：匹配一个字符</li><li>ls    -t 按时间降序排列</li><li>创建目录：mkdir</li><li>mv 目标文件 目录  或者可以改名字 mv 旧文件名 新文件名</li><li>cp 复制 参数 -r 递归复制</li><li>windows下 ping -n 包的个数 ip地址或域名    Linux下 ping -c 包的个数 ip地址或域名</li><li>显示文本文件内容：cat、more、tail<ul><li>cat 显示整个文件内容</li><li>more 分页显示文件内容，空格下一页，b 显示上一页，q 退出</li><li>tail -f 显示文本内容最后几行，对于程序员非常重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行</li></ul></li><li>wc 统计文本文件的行数、单词数和大小</li><li>grep 搜索</li><li>find 搜索</li><li>增加/删除用户组：groupadd 组名    groupdel 组名</li><li>添加/删除用户：useradd -n 用户名 -g 组名 -d 用户主目录<ul><li>userdel 用户名</li></ul></li><li>修改用户密码：passwd [用户名]</li><li>切换用户 su - root</li><li>修改目录和文件所有者和组：chwon [-R] 用户名：组名 目录或文件名列表  <ul><li>-R参数表示处理各级子目录</li></ul></li><li>查看系统磁盘空间：df [-h] [-T]<ul><li>参数 -h 以方便阅读的方式显示， -T 列出文件系统类型</li></ul></li><li>修改主机名 hostname<ul><li>vi /etc/hostname</li></ul></li></ol><h1 id="二、Vim-编辑器"><a href="#二、Vim-编辑器" class="headerlink" title="二、Vim 编辑器"></a>二、Vim 编辑器</h1><p>Vi 编辑器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">命令行模式：  i进入插入模式  esc进入命令行模式  <span class="token builtin class-name">:</span>进入末行模式  a在当前光标之后进入插入模式  o在当前光标下一行插入空行  O在当前光标上一行插入空行  I在当前光标行首进入插入模式  A在当前光标行末进入插入模式Ctrl + u 向上翻半页Ctrl + d 向下翻半页nG移动到第 n 行Ctrl + g显示当前所在行数G跳到最后一行：5光标跳到第5行：n光标跳到第n行<span class="token number">0</span>跳到行首$跳到行末w光标跳到下个单词的开头b光标跳到上个单词的开头e光标跳到本单词的结尾x每按一次，删除光标所在位置的一个字符nx如“3x”表示删除光标所在位置开始的3个字符dw删除光标所在位置到本单词结尾的字符D删除本行光标所在位置后面全部内容<span class="token function">dd</span>删除光标所在行ndd如“3dd”表示删除光标所在位置开始的3行yy将光标所在位置的一行复制到缓冲区nyy将光标所在位置的n行复制到缓冲区p将缓冲区的内容粘贴到光标所在位置r替换光标所在位置的一个字符r <span class="token operator">=</span> replaceR从光标所在位置开始替换，直到按下“Esc”cw从光标所在位置开始替换单词，知道按下“Esc”u撤销命令，可多次撤销J将当前行的下一行接到当前行的末尾/输入/和要查找的内容，然后 n 表示下一个，N 表示上一个, 撤销高亮输入 :nohl<span class="token builtin class-name">.</span>小数点表示重复执行上一次的vi命令~对当前光标所在的字符进行大小写转换列操作：先按 Ctrl + <span class="token function">v</span> 然后 按上下键选择列，选中后按 I 输入内容，最后 Esc移动光标：h 向左 l 向右  j 向下 k 向上 ：g/aaa/s//bbb/g全文替换，把aaa替换为bbb复制 ctrl + insert 粘贴 <span class="token builtin class-name">shift</span> + insert末行模式：:w存盘:w<span class="token operator">!</span>强制存盘:wq存盘退出:x存盘退出:q不存盘退出:q<span class="token operator">!</span>不存盘强制退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、makefile-文件"><a href="#三、makefile-文件" class="headerlink" title="三、makefile 文件"></a>三、makefile 文件</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在软件的工程中的源文件是很多的，其按照类型、功能、模块分别放在若干个目录和文件中，哪些文件需要编译，那些文件需要后编译，那些文件需要重新编译，甚至进行更复杂的功能操作，这就有了我们的系统编译的工具。在linux和unix中，有一个强大的实用程序，叫make，可以用它来管理多模块程序的编译和链接，直至生成可执行文件。make程序需要一个编译规则说明文件，称为makefile，makefile文件中描述了整个软件工程的编译规则和各个文件之间的依赖关系。makefile就像是一个shell脚本一样，其中可以执行操作系统的命令，它带来的好处就是我们能够实现“自动化编译”，一旦写好，只要一个make命令，整个软件功能就完全自动编译，提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说大多数编译器都有这个命令，使用make可以是重新编译的次数达到最小化。一、makefile 的编写makefile文件的规则可以非常复杂，比C程序还要复杂，我通过示例来介绍它的简单用法。文件名：makefile，内容如下：all:book1 book2book1:book1.cgcc -o book1 book1.cbook2:book2.c  _public.h _public.cgcc -o book2 book2.c  _public.cclean:<span class="token function">rm</span> -f book1 book2第一行：all：book1 book2all：这是固定的写法，后面跟的是要编译目标程序的清单，中间用空格分开，如果清单很长，可以用 <span class="token punctuation">\</span> 换行第二行：book1: book1.cbook1: 表示需要编译的目标程序如果要编译目标程序book1，需要依赖源程序book1.c，当book1.c的内容发生了变化，执行make的时候就会重新编译book1。第三行：gcc -o book book1.c这是一个编译命令，和在操作系统命令行输入的命令一样，但是要注意一个问题，在gcc之前要用tab键，看上去像8个空格，实际不是，一定要用tab，空格不行。第四行：book2: book2.c  _public.h _public.cbook2表示编译的目标程序。如果要编译目标程序book46，需要依赖源程序book46.c、_public.h和_public.c三个文件，只要任何一个的内容发生了变化，执行make的时候就会重新编译book46。第五行：gcc -o book46 book46.c _public.c第六行：clean：清除目标文件，清除的命令由第十行之后的脚本来执行。第七行：<span class="token function">rm</span>  -f  book1 book46清除目标文件的脚本命令，注意了，rm之前也是一个tab键，不是空格。二、make 命令makefile准备好了，在命令提示符下执行 <span class="token operator">&lt;</span>b<span class="token operator">&gt;</span>make<span class="token operator">&lt;</span>/b<span class="token operator">&gt;</span> 就可以编译makefile中all参数指定的目标文件。执行 <span class="token function">make</span> 编译目标程序执行 <span class="token function">make</span> clean 执行清除目标文件的指令三、makefile 文件中的变量makefile中，变量就是一个名字，变量的值就是一个文本字符串。在makefile中的目标，依赖，命令或其他地方引用变量时，变量会被它的值替代。<span class="token assign-left variable">CC</span><span class="token operator">=</span>gcc<span class="token assign-left variable">FLAG</span><span class="token operator">=</span>-g all:book1 book46 book1:book1.c        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>FLAG<span class="token variable">)</span></span> -o book1 book1.c book46:book46.c _public.h _public.c        <span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>FLAG<span class="token variable">)</span></span> -o book46 book46.c _public.c clean:        <span class="token function">rm</span> -f book1 book46第一行：<span class="token assign-left variable">CC</span><span class="token operator">=</span>gcc定义变量CC，赋值gcc第二行：<span class="token assign-left variable">FLAG</span><span class="token operator">=</span>-g定义变量，赋值-g第七行：<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span>  <span class="token variable"><span class="token variable">$(</span>FLAG<span class="token variable">)</span></span> -o book1 book1.c<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span>和<span class="token variable"><span class="token variable">$(</span>FLAG<span class="token variable">)</span></span>就是使用变量CC和FLAG的值，类似于C语言的宏定义，替换后的结果是：gcc -g -o book1 book1.c在makefile文件中，使用变量的好处有两个：1）如果在很多编译指令采用了变量，只要修改变量的值，就相当于修改全部的编译指令；2）把比较长的、公共的编译指令采用变量来表示，可以让makefile更简洁。四、应用经验makefile文件的编写可以很复杂，复杂到我不想看，在实际开发中，用不着那么复杂的makefile，我追求简单实用的方法，腾出更多的时间和精力去做更重要的事情，那些把makefile文件写得很复杂的程序员在我看来是吃饱了撑的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、GDB-常用命令"><a href="#四、GDB-常用命令" class="headerlink" title="四、GDB 常用命令"></a>四、GDB 常用命令</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">命令命令缩写命令说明<span class="token builtin class-name">set</span> args设置主程序的参数例如：两个程序  /test/book1.c和 ./book1.c设置方法：<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> args /test/book1.c和 gdb book1.c<span class="token builtin class-name">break</span>b设置断点，b <span class="token number">20</span> 表示在20行设置断点，可以设置多个断点runr开始运行程序，程序运行到断点处会停止nextn执行当前行语句，如果该语句为函数调用，不会进入函数内部steps执行当前行语句，如果该语句为函数调用，则进入函数执行第一天语句如果函数为库函数或第三方提供的函数，则无法进入printp显示变量值，例如 p name 表示显示变量name的值<span class="token builtin class-name">continue</span>c继续程序的运行，知道遇到下一个断点<span class="token builtin class-name">set</span> var name <span class="token operator">=</span> value设置变量的值，假设程序有两个变量：int ii 和 char name<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token builtin class-name">set</span> var ii <span class="token operator">=</span> <span class="token number">10</span> <span class="token builtin class-name">set</span> name <span class="token operator">=</span> ”测试“而不用strcpyquitq退出 gdb 环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、安装-CentOS-7"><a href="#五、安装-CentOS-7" class="headerlink" title="五、安装 CentOS 7"></a>五、安装 CentOS 7</h1><h2 id="1、安装步骤"><a href="#1、安装步骤" class="headerlink" title="1、安装步骤"></a>1、安装步骤</h2><p>首先正常安装，然后执行以下三个步骤：</p><blockquote><p>修改 CentOS 7 的字符集</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.gbk"</span> <span class="token operator">&gt;</span> /etc/locale.conf然后让其立即生效<span class="token builtin class-name">source</span> /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>启用网卡</p></blockquote><p>打开 ens33 网卡的配置文件 <code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>，把 <strong>NOBOOT</strong> 参数修改为 yes。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes <span class="token operator">&gt;&gt;</span> /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>修改 CentOS 7 的时间</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> -s <span class="token string">"2021/03/12 21:22:00"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、Linux-常用命令"><a href="#2、Linux-常用命令" class="headerlink" title="2、Linux 常用命令"></a>2、Linux 常用命令</h2><ul><li>重启： <code>init 6 或者 reboot</code></li><li>关机：<code>init 0 或者 halt</code></li></ul><blockquote><p>时间操作：</p></blockquote><ul><li><p>查看时间 <code>date</code></p></li><li><p>设置时间为中国上海时间  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置时间格式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> -s <span class="token string">"yyyy-mm-dd hh:mi:ss"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><blockquote><p>目录操作：</p></blockquote><ul><li><p>删除目录和文件：<code>rm [-rf] 目录或文件列表</code></p></li><li><p>移动目录或文件：<code>mv 旧目录或文件名 新目录或文件名</code> 也可以重命名</p></li><li><p>复制目录或文件：<code>cp [-r] 旧目录或文件名 新目录或文件名</code></p></li></ul><p>打包压缩与解压缩：</p><ul><li>打包压缩的语法：<code>tar zcvf 压缩包文件名 目录或文件名列表</code></li><li>解包解压的语法：<code>tar zxvf 压缩包文件名</code></li></ul><blockquote><p>判断网络是否连通：</p></blockquote><ul><li>Windows系统：<code>ping -n 包的个数 ip地址或域名</code></li><li>Linux系统：<code>ping -c 包的个数 ip地址或域名</code></li></ul><blockquote><p>搜索文件中的内容</p></blockquote><p><code>grep "内容" 文件名</code></p><p>注意，如果内容中没有空格等特殊字符，可以不用双引号括起来。</p><p>可以使用通配符</p><blockquote><p>搜索文件</p></blockquote><p><code>find 目录名 -name 文件名 -print</code></p><p>参数说明：</p><p>目录名：待搜索的目录，搜索文件的时候，除了这个目录名，还包括它的各级子目录。</p><p>文件名：待搜索的文件名匹配的规则。</p><p>示例：</p><p>1）从/tmp目录开始搜索，把全部的*.c文件显示出来。</p><p>find /tmp -name *.c -print</p><p>2）从当前工作目录开始搜索，把全部的*.c文件显示出来。</p><p>find . -name *.c -print</p><blockquote><p>增加/删除用户组</p></blockquote><ul><li>增加用户组：<code>groupadd 组名</code></li><li>删除用户组：<code>groupdel 组名</code></li></ul><blockquote><p>增加/删除用户&amp;修改用户密码</p></blockquote><ul><li><p>增加用户：<code>useradd -n 用户名 -g 组名 -d 用户的主目录</code></p></li><li><p>删除用户：<code>userdel 用户名</code></p></li><li><p>修改用户密码：<code>passwd [用户名]</code></p><p>修改用户的密码，按提示两次输入新密码，如果两次输入的密码相同就修改成功。</p><p>普通用户只能修改自己的密码，只输入passwd就可以了，不能指定用户名。</p><p>系统管理员可以修改任何用户的密码，passwd后需要指定用户名。</p></li></ul><blockquote><p>修改目录和文件的所有者和组</p></blockquote><p><code>chown [-R] 用户名:组名 目录或文件名列表</code></p><p>chown将目录或文件的拥有者修改为参数指定的用户名和组，目录或文件名列表用空格分隔。</p><p>-R 选项表示处理各及子目录。</p><blockquote><p>查看系统磁盘空间</p></blockquote><p><code>df [-h] [-T]</code></p><p>选项-h 以方便阅读的方式显示信息。</p><p>选项-T 列出文件系统类型。</p><h1 id="六、CentOS-7-设置环境变量"><a href="#六、CentOS-7-设置环境变量" class="headerlink" title="六、CentOS 7 设置环境变量"></a>六、CentOS 7 设置环境变量</h1><h2 id="1、环境变量的含义"><a href="#1、环境变量的含义" class="headerlink" title="1、环境变量的含义"></a>1、环境变量的含义</h2><p>程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。</p><h2 id="2、环境变量的分类"><a href="#2、环境变量的分类" class="headerlink" title="2、环境变量的分类"></a>2、环境变量的分类</h2><ul><li>按生效的范围分类<ul><li><strong>系统环境变量</strong>：公共的，对全部的用户都生效。</li><li><strong>用户环境变量</strong>：用户私有的、自定义的个性化设置，只对该用户生效。</li></ul></li><li>按生存周期分类<ul><li><strong>永久环境变量</strong>：在环境变量脚本文件中配置，用户每次登录时会自动执行这些脚本，相当于永久生效。</li><li><strong>临时环境变量</strong>：使用时在Shell中临时定义，退出Shell后失效。</li></ul></li></ul><h2 id="3、Linux-环境变量"><a href="#3、Linux-环境变量" class="headerlink" title="3、Linux 环境变量"></a>3、Linux 环境变量</h2><p>Linux环境变量也称之为Shell环境变量，以下划线和字母打头，由下划线、字母（区分大小写）和数字组成，习惯上使用大写字母，例如 PATH、HOSTNAME、LANG 等。</p><h2 id="4、常用的环境变量"><a href="#4、常用的环境变量" class="headerlink" title="4、常用的环境变量"></a>4、常用的环境变量</h2><blockquote><p>查看环境变量</p></blockquote><p><code>env 命令</code>：</p><p>在 Shell 下，用 env 命令查看当前用户全部的环境变量。</p><p>用 env 命令的时候，满屏显示了很多环境变量，不方便查看，可以用 grep 筛选。</p><p><code>env | grep 环境变量名</code>:</p><p>例如查看环境变量名中包含PATH的环境变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>echo 命令</code>:</p><p>echo $环境变量名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$LANG</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>常用的环境变量</p></blockquote><ul><li><p>PATH</p><p>可执行程序的搜索目录，可执行程序包括 Linux 系统命令和用户的应用程序</p></li><li><p>LANG</p><p>Linux系统的语言、地区、字符集</p></li><li><p>HOSTNAME</p><p>服务器的主机名。</p></li><li><p>SHELL</p><p>用户当前使用的Shell解析器。</p></li><li><p>HISTSIZE</p><p>保存历史命令的数目。</p></li><li><p>USER</p><p>当前登录用户的用户名。</p></li><li><p>HOME</p><p>当前登录用户的主目录。</p></li><li><p>PWD</p><p>当前工作目录。</p></li><li><p>LD_LIBRARY_PATH</p><p>C/C++语言动态链接库文件搜索的目录，它不是 Linux 缺省的环境变量，但对C/C++程序员来说非常重要</p></li><li><p>CLASSPATH</p><p><strong>JAVA 语言库文件搜索的目录，它也不是 Linux 缺省的环境变量，但对JAVA程序员来说非常重要</strong></p></li></ul><h2 id="5、设置环境变量"><a href="#5、设置环境变量" class="headerlink" title="5、设置环境变量"></a>5、设置环境变量</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">变量名<span class="token operator">=</span><span class="token string">'值'</span><span class="token builtin class-name">export</span> 变量名或者<span class="token builtin class-name">export</span> 变量名<span class="token operator">=</span><span class="token string">'值'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果环境变量的值没有空格等特殊符号，可以不用单引号包含。</p><p>示例：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ORACLE_HOME</span><span class="token operator">=</span>/oracle/homeexport <span class="token assign-left variable">ORACLE_BASE</span><span class="token operator">=</span>/oracle/baseexport <span class="token assign-left variable">ORACLE_SID</span><span class="token operator">=</span>snorcl11gexport <span class="token assign-left variable">NLS_LANG</span><span class="token operator">=</span><span class="token string">'Simplified Chinese_China.ZHS16GBK'</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token environment constant">$HOME</span>/bin:<span class="token variable">$ORACLE_HOME</span>/bin:.export <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span><span class="token builtin class-name">:</span><span class="token variable">$ORACLE_HOME</span>/lib:.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>采用export设置的环境变量，在退出 Shell 后就会失效，下次登录时需要重新设置。如果希望环境变量永久生效，需要在登录脚本文件中配置。</p><blockquote><p>系统环境变量</p></blockquote><p>系统环境变量对全部的用户生效，设置系统环境变量有三种方法。</p><ul><li><p>在 <code>/etc/profile</code> 文件中设置。</p><p>用户登录时执行 /etc/profile 文件中设置系统的环境变量。但是，Linux不建议在/etc/profile文件中设置系统环境变量。</p></li><li><p>在 <code>/etc/profile.d</code> 目录中增加环境变量脚本文件，这是Linux推荐的方法。（推荐使用）</p><p>/etc/profile在每次启动时会执行 /etc/profile.d下全部的脚本文件。/etc/profile.d 比 /etc/profile 好维护，不想要什么变量直接删除 /etc/profile.d下对应的 <strong>shell 脚本</strong>即可。</p></li><li><p>在 <code>/etc/bashrc</code> 文件中设置环境变量。</p><p>该文件配置的环境变量将会影响全部用户使用的bash shell。但是，Linux也不建议在/etc/bashrc文件中设置系统环境变量。</p></li></ul><blockquote><p>用户环境变量</p></blockquote><p>用户环境变量只对当前用户生效，设置用户环境变量也有多种方法。</p><p>在用户的主目录，有几个特别的文件，用 ls 是看不见的，用 <strong>ls .bash_</strong>* 可以看见。</p><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /root/.bash_*ls /home/naivekyo/.bash_*可以查出来几个特别的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>.bash_profile</code>（推荐首选）</p><p>当用户登录时执行，每个用户都可以使用该文件来配置专属于自己的环境变量。</p></li><li><p><code>.bashrc</code></p><p>当用户登录时以及每次打开新的 Shell 时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。</p></li><li><p><code>.bash_logout</code></p><p>当每次退出系统（退出bash shell）时执行该文件。</p></li><li><p><code>.bash_history</code></p><p>保存了当前用户使用过的历史命令。</p></li></ul><blockquote><p>环境变量脚本执行的顺序</p></blockquote><p>环境变量脚本文件的执行顺序如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/profile -<span class="token operator">&gt;</span> /etc/profile.d -<span class="token operator">&gt;</span> /etc/bashrc -<span class="token operator">&gt;</span> 用户的.bash_profile -<span class="token operator">&gt;</span> 用户的.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同名的环境变量，如果在多个脚本中有配置，以最后执行的脚本中的配置为准。</p><p>还有一个问题需要注意，在/etc/profile中执行了/etc/profile.d的脚本，代码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> /etc/profile.d/*.sh <span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">$i</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">${-<span class="token operator">#</span>*i}</span>"</span> <span class="token operator">!=</span> <span class="token string">"$-"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>            <span class="token builtin class-name">.</span> <span class="token string">"<span class="token variable">$i</span>"</span>        <span class="token keyword">else</span>            <span class="token builtin class-name">.</span> <span class="token string">"<span class="token variable">$i</span>"</span> <span class="token operator">&gt;</span>/dev/null        <span class="token keyword">fi</span>    fidone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，/etc/profile.d 和 /etc/profile 的执行顺序还要看代码怎么写。</p><h2 id="6、重要环境变量详解"><a href="#6、重要环境变量详解" class="headerlink" title="6、重要环境变量详解"></a>6、重要环境变量详解</h2><blockquote><p>1、PATH 环境变量</p></blockquote><p>可执行程序的搜索目录，可执行程序包括 Linux 系统命令和用户的应用程序。如果可执行程序的目录不在 PATH 指定的目录中，执行时需要指定目录。</p><ul><li><p>PATH环境变量存放的是目录列表，目录之间用冒号 : 分隔，最后的圆点 . 表示当前目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>目录1:目录2:目录3:<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>目录n:.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>PATH 缺省包含了 Linux 系统命令所在的目录（/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin），如果不包含这些目录，Linux的常用命令也无法执行（要输入绝对路径才能执行）。</p></li><li><p>在用户的 .bash_profile 文件中，会对PATH进行扩充，如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token environment constant">$HOME</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果PATH变量中没有包含<strong>圆点</strong>.，执行当前目录下的程序需要加./或使用绝对路径。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 没有圆点</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/bin<span class="token comment"># 执行该目录下的命令时需要使用 ./ 或者 绝对路径</span><span class="token comment"># 加上圆点</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/bin:.<span class="token comment"># 可以在任何地方执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>2、LANG 环境变量</p></blockquote><p>LANG环境变量存放的是Linux系统的语言、地区、字符集，它不需要系统管理员手工设置，/etc/profile 会调用 /etc/profile.d/lang.sh 脚本完成对LANG的设置。</p><ul><li><p>CentOS6.x 字符集配置文件在/etc/syscconfig/i18n文件中。</p></li><li><p>CentOS7.x 字符集配置文件在/etc/locale.conf文件中，内容如下：</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8<span class="token comment">#LANG=zh_CN.UTF-8</span><span class="token comment">#LANG=zh_CN.gbk</span><span class="token comment">#LANG=zh_CH.gb18030</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>3、LD_LIBRARY_PATH环境变量</p></blockquote><p>C/C++语言动态链接库文件搜索的目录，它不是Linux缺省的环境变量，但对C/C++程序员来说非常重要。LD_LIBRARY_PATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>目录1:目录2:目录3:<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>目录n:.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>4、CLASSPATH</p></blockquote><p>JAVA语言库文件搜索的目录，它也不是Linux缺省的环境变量，但对JAVA程序员来说非常重要。</p><p>CLASSPATH环境变量存放的也是目录列表，目录之间用冒号:分隔，最后的圆点.表示当前目录，与PATH的格式相同。</p><h2 id="7、环境变量的生效"><a href="#7、环境变量的生效" class="headerlink" title="7、环境变量的生效"></a>7、环境变量的生效</h2><ul><li><p>在 Shell 下，用 <strong>export</strong> 设置的环境变量对当前 Shell 立即生效，Shell 退出后失效。</p></li><li><p>在脚本文件中设置的环境变量不会立即生效，退出 Shell 后重新登录时才生效，或者用 <strong>source</strong> 命令让它立即生效，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="8、建议"><a href="#8、建议" class="headerlink" title="8、建议"></a>8、建议</h2><p>虽然设置环境变量的方法有多种，但是建议系统环境变量建议在 <strong>/etc/profile.d</strong> 目录中配置，用户环境变量在用户的 <strong>.bash_profile</strong> 中配置，不建议在其它脚本文件中配置环境变，会增加运维的麻烦，容易出错。</p><h1 id="七、CentOS7-设置中文字符集"><a href="#七、CentOS7-设置中文字符集" class="headerlink" title="七、CentOS7 设置中文字符集"></a>七、CentOS7 设置中文字符集</h1><h1 id="八、CentOS7-安装软件包的方法"><a href="#八、CentOS7-安装软件包的方法" class="headerlink" title="八、CentOS7 安装软件包的方法"></a>八、CentOS7 安装软件包的方法</h1><p>Linux有多种发行版本，各种发行版本之间安装软件包的方法和命令不一样，同发行版本之间安装软件包的方法也有不同。Linux主要有三大派系：红帽子派系（Redhat、Centos、Oracle Linux）、Debian派系（Ubuntu、Kali），SUSE派系（SuSe、OpenSUSE）等。</p><p>红帽子派是Linux服务器操作系统的主流，本文重点介绍红帽子派系中rpm和yum安装软件包的方法。</p><h2 id="1、rpm-安装"><a href="#1、rpm-安装" class="headerlink" title="1、rpm 安装"></a>1、rpm 安装</h2><p>RPM是RedHat Package Manager的缩写，由RedHat推出的软件包管理管理工具，在Fedora 、Redhat、CentOS、Mandriva、SuSE、YellowDog等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用。</p><p>RPM包里面包含可执行的二进制程序，自身所带的附加文件，版本文件（软件包的依赖关系）。</p><ul><li><p>查看系统中已经安装的软件包</p></li><li><p>rpm -q 软件包名  例如 ftp 查看已经安装的软件包</p></li><li><p>rpm -ql 软件包名 查看软件包安装的目录和文件（包括了可执行程序、配置文件和帮助文档）。</p></li><li><p>rpm -qi 软件包名 查看已安装软件包的详细信息。</p></li><li><p>rpm -qc 软件包名 查看已安装软件包的配置文件所在的位置。</p></li><li><p>rpm -qR 软件包名 查看已安装软件包所依赖的软件包及文件。</p></li></ul><ul><li><p>查看软件包的安装文件，安装包文件的后缀是.rpm</p></li><li><p>rpm -qpi 软件包的安装文件名 查看一个软件包的安装文件的详细信息。</p></li><li><p>rpm -qpl 软件安装包文件名 查看软件包的安装文件所包含的文件。</p></li><li><p>rpm -qpR 软件包的安装文件名 查看软件包的依赖关系。</p></li></ul><p>软件包的安装文件： 安装包文件的后缀是.rpm，以CentOS7为例，系统安装的光盘映像文件是CentOS-7-x86_64-DVD-1908.iso，解开后在Packages目录中有软件包的安装文件</p><p><strong>安装/升级软件包</strong></p><p>如果待安装/升级的软件与其它的软件有依赖关系，请解决依赖关系，即先安装/升级依赖关系的软件包。如果没有解决好依赖关系，可以强制安装/升级，不推荐采用强制的方法，因为有可能导致软件不可用。</p><ul><li>安装软件包：rpm -ivh 软件包的安装文件名</li><li>升级软件包：rpm -Uvh 软件包的安装文件名</li><li>强制安装软件包：rpm -ivh 软件包的安装文件名 –nodeps –force</li><li>强制升级软件包：rpv -Uvh 软件包的安装文件名 –nodeps –force</li><li>删除软件包：rpm -e 软件包名</li></ul><h2 id="2、yum-安装"><a href="#2、yum-安装" class="headerlink" title="2、yum 安装"></a>2、yum 安装</h2><p>rpm安装软件包的虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件包需要安装多个其他软件包，还有不同版本的兼容性问题，很复杂。yum（Yellow dog Updater, Modified）解决了这些问题，yum是rpm的前端程序，设计的主要目的就是为了自动解决rpm的依赖关系，有以下优点：</p><ol><li><p>自动解决依赖关系；</p></li><li><p>可以对rpm进行分组，基于组进行安装操作；</p></li><li><p>引入仓库概念，支持多个仓库；</p></li><li><p>配置简单。</p></li></ol><blockquote><p>yum 的语法</p></blockquote><p><code>yum [options] [command] [package ...]</code></p><p>options：可选参数：</p><p>1）-h帮助；</p><p>2）-y，当安装过程提示选择全部为yes，不需要再次确认；</p><p>3）-q，不显示安装的过程。</p><p>command：待操作的命令。</p><p>package：待操作的软件包名，多个软件包之间用空格分开，支持用星号*匹配。</p><blockquote><p>yum 的常用命令</p></blockquote><ul><li><strong>安装/升级软件包</strong>：yum install 软件包名/软件包文件名</li><li><strong>升级软件包</strong>：yum update 软件包名</li><li><strong>删除软件包</strong>：yum remove 软件包名</li><li><strong>查找软件包</strong>：yum search 软件包名</li><li>列出所有可更新的软件包清单：yum check-update</li><li>更新所有软件包：yum update</li><li>列出所有可安装软件包的清单：yum list</li><li>清除缓存：yum clean [headers|packages|metadata|dbcache|plugins|expire-cache|all]<ul><li>rm -rf /var/cache/yum</li><li>生成缓存 ： yum makecache</li></ul></li></ul><blockquote><p>示例</p></blockquote><p>1）安装/升级ftp客户端软件包。</p><p>yum -y install ftp</p><p>或</p><p>yum -y install ftp-0.17-67.el7.x86_64.rpm</p><p>2）升级ftp客户端软件包</p><p>yum -y update ftp</p><p>3）删除ftp客户端软件包。</p><p>yum -y remove ftp</p><h2 id="3、应用经验"><a href="#3、应用经验" class="headerlink" title="3、应用经验"></a>3、应用经验</h2><p>1）rpm安装/升级软件包需要手工的解决包的依赖关系，这一点让人确实很烦，所以，软件包的安装/升级一般采用yum命令。</p><p>2）rpm的某些功能，例如查看软件包的详细信息、软件包的安装目录、软件包的配置文件等还是有实用价值的。</p><h1 id="九、CentOS7-系统服务管理"><a href="#九、CentOS7-系统服务管理" class="headerlink" title="九、CentOS7 系统服务管理"></a>九、CentOS7 系统服务管理</h1><h2 id="1、systemctl介绍"><a href="#1、systemctl介绍" class="headerlink" title="1、systemctl介绍"></a>1、systemctl介绍</h2><p>CentOS7启用了新的系统和服务管理器，采用systemctl命令代替了老版本的service和chkconfig。为了保持兼容性，在CentOS7中，老版本的service和chkconfig命令仍然可以使用。</p><p>systemctl命令是system（系统）和control（控制）两个单词的简写，它是一个功能强大的命令，本文只介绍与服务管理相关的用法。</p><p>systemctl命令有一点不足，就是很多命令执行后没有提示信息</p><h2 id="2、systemctl常用命令"><a href="#2、systemctl常用命令" class="headerlink" title="2、systemctl常用命令"></a>2、systemctl常用命令</h2><ul><li><p>start：.service 可以省略</p></li><li><p>stop</p></li><li><p>restart</p></li><li><p>查看服务是否已启动：systemctl is-active name.service</p></li><li><p>status</p><ul><li><p>Loaded：关于服务是否已经加载的信息，文件的绝对路径以及是否被启用的注释。</p><p>Active：服务是否正在运行,然后是启动时间信息。</p><p>Process：进程额外信息。</p><p>Main PID：服务主进程pid。</p><p>CGroup:Control Groups额外信息。</p></li></ul></li><li><p>开机自启动：systemctl enable name.service</p></li><li><p>停用开机自启：systemctl disable name.service</p></li><li><p>查看服务是否开机自启：systemctl is-enabled name.service</p></li><li><p>只重启正在运行的服务：systemctl try-restart name.service</p></li><li><p>显示所有服务状态：systemctl list-units –type service –all</p></li><li><p>查看启动成功的服务：systemctl list-unit-files|grep enabled</p></li><li><p>查看启动失败的服务：systemctl –failed</p></li><li><p>查看所有服务状态：systemctl list-unit-files –type service</p></li><li><p>列出在指定服务之前启动的服务（依赖）：systemctl list-dependencies –after name.service</p></li><li><p>列出在指定服务之后启动的服务（被依赖）：systemctl list-dependencies –before name.service</p></li></ul><h1 id="十、CentOS7-配置防火墙"><a href="#十、CentOS7-配置防火墙" class="headerlink" title="十、CentOS7 配置防火墙"></a>十、CentOS7 配置防火墙</h1><p>防火墙技术是用于安全管理的软件和硬件设备，在计算机内/外网之间构建一道相对隔绝的保护屏障，以保护数据和信息安全性的一种技术。</p><p>防火墙分为网络防火墙和主机防火墙。</p><p>网络防火墙由软件和硬件组成，可以保护整个网络，价格也很贵，从几万到几十万的都有，功能非常强大，主要包括入侵检测、网络地址转换、网络操作的审计监控、强化网络安全服务等功能。</p><p>主机防火墙只有软件部分（操作系统和杀毒软件自带），用于保护本操作系统，功能比较简单，只能防范简单的攻击。</p><p>本文将介绍主机防火墙（CentOS7以上版本）的使用和配置。</p><blockquote><p>防火墙配置</p></blockquote><p>CentOS7的防火墙比CentOS6的功能更强大，配置方法和操作命令也完全不同。</p><p>CentOS7的防火墙规则既可以是端口，也可以是服务。</p><p>防火墙查看和配置以下介绍的命令，如果没有特别说明就表示需要管理员权限执行。</p><h2 id="1、查看防火墙的命令"><a href="#1、查看防火墙的命令" class="headerlink" title="1、查看防火墙的命令"></a>1、查看防火墙的命令</h2><ul><li>查看防火墙的版本。firewall-cmd –version</li><li>查看firewall的状态。firewall-cmd –state</li><li>查看firewall服务状态（普通用户可执行）。systemctl status firewalld</li><li>查看防火墙全部的信息。firewall-cmd –list-all</li><li>查看防火墙已开通的端口。firewall-cmd –list-port</li><li>查看防火墙已开通的服务。firewall-cmd –list-service</li><li>查看全部的服务列表（普通用户可执行）。firewall-cmd –get-services</li><li>查看防火墙服务是否开机启动。systemctl is-enabled firewalld</li></ul><h2 id="2、配置防火墙的命令"><a href="#2、配置防火墙的命令" class="headerlink" title="2、配置防火墙的命令"></a>2、配置防火墙的命令</h2><ul><li>启动、重启、关闭防火墙服务。<ul><li>systemctl start firewalld </li><li>systemctl restart firewalld</li><li>systemctl stop firewalld</li></ul></li><li>开放、移去某个端口。<ul><li>开放80端口：firewall-cmd –zone=public –add-port=80/tcp –permanent</li><li>移去80端口：firewall-cmd –zone=public –remove-port=80/tcp –permanent</li></ul></li><li>开放、移去范围端口。<ul><li>开放5000-5500之间的端口：firewall-cmd –zone=public –add-port=5000-5500/tcp –permanent</li><li>移去5000-5500之间的端口：firewall-cmd –zone=public –remove-port=5000-5500/tcp –permanent</li></ul></li><li>开放、移去服务。<ul><li>开放ftp服务：firewall-cmd –zone=public –add-service=ftp –permanent</li><li>移去http服务：firewall-cmd –zone=public –remove-service=ftp –permanent</li></ul></li><li>重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。<ul><li>firewall-cmd –reload</li></ul></li><li>设置开机时启用、禁用防火墙服务。<ul><li> 启用服务：systemctl enable firewalld</li><li> 禁用服务：systemctl disable firewalld</li></ul></li></ul><h2 id="3、centos7-之前的版本"><a href="#3、centos7-之前的版本" class="headerlink" title="3、centos7 之前的版本"></a>3、centos7 之前的版本</h2><p>1）开放80，22，8080 端口。</p><p>/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p><p>/sbin/iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p><p>/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p><p>2）保存。</p><p>/etc/rc.d/init.d/iptables save</p><p>3）查看打开的端口。</p><p>/etc/init.d/iptables status</p><p>4）启动、关闭防火墙服务。</p><p># 启动服务</p><p>service iptables start</p><p># 关闭服务</p><p>service iptables stop</p><p>5）设置开机时启用、禁用防火墙服务。</p><p># 启用服务</p><p>chkconfig iptables on</p><p># 禁用服务</p><p>chkconfig iptables off</p><h2 id="4、云平台访问策略配置"><a href="#4、云平台访问策略配置" class="headerlink" title="4、云平台访问策略配置"></a>4、云平台访问策略配置</h2><p>如果您购买的是云服务器，除了配置云服务器的防火墙，还需要登录云服务器提供商的管理平台配置访问策略（或安全组）。</p><p>不同云服务器提供商的管理平台操作方法不同，具体方法请查阅云服务器提供商的操作手册、或者百度，或者咨询云服务器提供商的客服。</p><h1 id="十一、SSH-学习"><a href="#十一、SSH-学习" class="headerlink" title="十一、SSH 学习"></a>十一、SSH 学习</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7_install_jenkins</title>
      <link href="/2021/07/07/centos7-install-jenkins/"/>
      <url>/2021/07/07/centos7-install-jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1、Jenkins-是什么"><a href="#1、Jenkins-是什么" class="headerlink" title="1、Jenkins 是什么"></a>1、Jenkins 是什么</h2><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p><h2 id="2、CI-CD-是什么"><a href="#2、CI-CD-是什么" class="headerlink" title="2、CI/CD 是什么"></a>2、CI/CD 是什么</h2><p> <code>CI(Continuous integration)</code>，中文意思是持续集成。它强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对 CI 加以理解。</p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/ci.png"></p><p><code>CD(Continuous Delivery)</code>， 中文意思持续交付。它是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是 CI/CD 的大概工作模式。</p><p><img src="https://naivekyo.oss-cn-hangzhou.aliyuncs.com/blog%27image/cd.png"></p><h1 id="二、安装-Jenkins"><a href="#二、安装-Jenkins" class="headerlink" title="二、安装 Jenkins"></a>二、安装 Jenkins</h1><p>环境：CentOS7</p><h2 id="1、前置"><a href="#1、前置" class="headerlink" title="1、前置"></a>1、前置</h2><ul><li><p>官网下载 LTS 版本的 war 包：<a href="https://www.jenkins.io/">https://www.jenkins.io/</a></p></li><li><p>上传到服务器    </p></li><li><p>运行 war 包，将其作为后台进程挂起，输出日志为 <code>jenkins.out</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> java -jar /usr/local/jenkins/jenkins.jar <span class="token operator">&gt;</span> /usr/local/jenkins/jenkins.out <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问 Jenkins 的管理页面：Linux IP + 8080 端口（<strong>需要开放端口</strong>）</p></li><li><p>登录密码位置：<code>/root/.jenkins/secrets/initialAdminPassword</code></p></li><li><p>获取密码后输入点击继续，会进入下载插件的界面，由于需要从外网下载，速度较慢，我们需要修改为国内的镜像：（先关掉浏览器界面 并 杀死 Linux 中的 jenkins 进程）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置国内镜像</span><span class="token comment"># 进入 jenkins 工作目录</span><span class="token builtin class-name">cd</span> /root/.jenkins/updates<span class="token comment"># 杀死进程: 先查 PID 然后 kill</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> jenkins<span class="token function">kill</span> -s <span class="token environment constant">TERM</span> <span class="token operator">&lt;</span>PID<span class="token operator">&gt;</span><span class="token comment"># 直接修改配置文件 default.json</span><span class="token comment"># 由于该文件内容太多，直接编辑不好修改，我们可以运行脚本进行修改</span><span class="token function">sed</span> -i <span class="token string">'s/http:Wupdates.jenkins-ci.orgVdownload/https:Wmirrors.tuna.tsinghua.edu.cnVjenkins/g'</span> default.json <span class="token operator">&amp;&amp;</span> <span class="token function">sed</span> -i <span class="token string">'s/http:Wwww.google.com/https:Wwww.baidu.com/g'</span> default.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重启 jenkins 下载插件：<strong>选择安装推荐的插件</strong></p></li><li><p>安装完成之后，创建管理员用户：</p></li><li><p>登录</p></li><li><p>进入管理页面后，开始配置 Jenkins</p><p>Manager Jenkins -&gt; Global Tool Configuration</p><p>分别配置 <mark>JDK、Maven、Git</mark></p></li></ul><h2 id="2、Jenkins-自动化配置"><a href="#2、Jenkins-自动化配置" class="headerlink" title="2、Jenkins 自动化配置"></a>2、Jenkins 自动化配置</h2><p>准备工作：</p><ul><li><p>服务器需安装  <mark>Docker</mark></p></li><li><p>需要在工程中添加 <strong>Dockerfile</strong> （和 pom 文件在同一级）</p></li></ul><blockquote><p>前置工作：Dockerfile</p></blockquote><p>Dockerfile：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 拉取 JDK 环境</span>FROM openjdk:8-jdk-alpine<span class="token comment"># 缓存处理</span>VOLUME /tmp<span class="token comment"># 重命名 jar 包</span>COPY ./target/jenkinsdemo-0.0.1-SNAPSHOT.jar demojenkins.jar<span class="token comment"># 执行 jar 包</span>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"java"</span>,<span class="token string">"-jar"</span>,<span class="token string">"/demojenkins.jar"</span>, <span class="token string">"&amp;"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 pom.xml </p><ul><li>更改打包类型为 pom</li><li>添加 maven 插件</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.naivekyo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jenkinsdemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>jenkinsdemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Jenkins-管理界面创建自动化任务"><a href="#3、Jenkins-管理界面创建自动化任务" class="headerlink" title="3、Jenkins 管理界面创建自动化任务"></a>3、Jenkins 管理界面创建自动化任务</h2><ul><li>Jenkins dashboard -&gt; 新建 Item</li><li>填写任务名称：可随意</li><li>一般选择 <strong>Freestyle project</strong> 即可</li><li>下一步：源代码管理，这里我们将没有编译的代码（mvn：clean）上传到远程仓库中，Jenkins 支持两种仓库 GitHub 和 gitee，但是我只找到了 GitHub 一种</li></ul><hr><blockquote><p>使用 Git 将 springboot 项目上传到 GitHub</p></blockquote><ol><li>在 GitHub 上新建仓库</li><li>记录下仓库的地址，例如 <a href="https://github.com/NaiveKyo/JenkinsTest.git">https://github.com/NaiveKyo/JenkinsTest.git</a></li><li>本机打开 git 的客户端，进入自己要提交的工程的目录</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 举个例子</span><span class="token comment"># 工程目录下右键 打开 git bash here</span><span class="token comment"># 第一步，初始化</span><span class="token function">git</span> init<span class="token comment"># 第二步，上传，这里直接是将所有文件添加到仓库中，如果只想添加指定的文件，可以把 . 换成特定的文件名称</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token comment"># 第三步，提交到本地仓库</span><span class="token function">git</span> commit -m <span class="token string">"description"</span> <span class="token comment"># 表示提交的注释</span><span class="token comment"># 可能需要输入 GitHub 账户名和密码</span><span class="token comment"># 可以使用以下方式配置全局信息，以后比较方便</span><span class="token function">git</span> config --global user.email <span class="token string">"Your Email"</span><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span><span class="token comment"># 第四步，和远程仓库相关联</span><span class="token function">git</span> remote <span class="token function">add</span> origin https://仓库url<span class="token comment"># 最后，上传到远程仓库，指定分支 master</span><span class="token function">git</span> push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li>将本地代码上传到远程仓库 <a href="https://github.com/NaiveKyo/JenkinsTest.git">https://github.com/NaiveKyo/JenkinsTest.git</a></li><li>Jenkins Dashboard 新建 Item，设置好配置信息</li><li><strong>注意：开始构建之前，必须开启 Docker</strong></li><li>开始构建项目</li><li>Build Success</li></ul><h2 id="4、Jenkins-执行任务时遇到的错误"><a href="#4、Jenkins-执行任务时遇到的错误" class="headerlink" title="4、Jenkins 执行任务时遇到的错误"></a>4、Jenkins 执行任务时遇到的错误</h2><p>git 一直无法拉取远程仓库地址：</p><blockquote><p>推荐方案一，剩下两种没测试</p></blockquote><ul><li><p>尝试过配置 ssh，但是无效</p></li><li><p><strong>最终解决方案</strong>：</p><ul><li><strong>缺少插件</strong>：curl-devel ：Jenkins 通过 git 发起 http 请求需要使用工具 <code>curl-devel</code>（我只安装了 wget）</li><li>重新编译 git</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/git/git_x.x.x./configuration --prefix<span class="token operator">=</span>/usr/local/git<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>方式二：<code>yum install git-http</code></p></li><li><p>方式三：git 代替 https <code>git clone --recursive git://github.com/用户名/仓库地址</code></p></li></ul><h1 id="三、补充知识"><a href="#三、补充知识" class="headerlink" title="三、补充知识"></a>三、补充知识</h1><h2 id="1、Linux-知识"><a href="#1、Linux-知识" class="headerlink" title="1、Linux 知识"></a>1、Linux 知识</h2><h3 id="（1）nohup"><a href="#（1）nohup" class="headerlink" title="（1）nohup"></a>（1）nohup</h3><p>nohup 命令全程 no hang up，用于在系统后台不挂断的运行命令，退出终端不会影响程序的运行。</p><p>nohup 命令，在默认情况下（非重定向时），会输出一个名叫 <code>nohup.out</code> 的文件到当前目录下，如果当前目录的 nohup.out 不可写，输出重定向到 <code>$HOME/nohup.out</code> 文件中。</p><h3 id="（2）标准输入、输出"><a href="#（2）标准输入、输出" class="headerlink" title="（2）标准输入、输出"></a>（2）标准输入、输出</h3><ul><li>标准输入：stdin  代码 0  用 &lt; 或 &lt;&lt; 表示</li><li>标准输出：stdout 代码 1 用 &gt; 或 &gt;&gt; 表示</li><li>标准错误输出：stderr 代码 2 用 2&gt; 或 2&gt;&gt; 表示</li></ul><p>将命令执行的正确信息和错误信息做处理：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 分别存放到不同的文件</span><span class="token function">find</span> /home -name .bashrc <span class="token operator">&gt;</span> /right.txt <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /error.ext<span class="token comment"># 丢弃错误信息，只保存正确信息</span><span class="token function">find</span> /home -name .bashrc <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null<span class="token comment"># 将正确和错误的信息输出到同一个文件</span><span class="token function">find</span> /home -name .bashrc <span class="token operator">&gt;</span> /right.txt <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span><span class="token comment"># 或者</span><span class="token function">find</span> /home -name .bashrc <span class="token operator">&amp;&gt;</span> /right.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准输入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 cat 命令简单的创建一个文件</span><span class="token function">cat</span> <span class="token operator">&gt;</span> text.txt<span class="token comment"># 然后输入消息，退出使用 ctrl + d</span><span class="token comment"># 使用 cat 和 &lt; 创建文件，可以实现类似复制文件的作用</span><span class="token function">cat</span> <span class="token operator">&gt;</span> text.txt <span class="token operator">&lt;</span> ./message.txt<span class="token comment"># 测试 &lt;&lt; 该符号代表 `结束的输入字符`</span><span class="token function">cat</span> <span class="token operator">&gt;</span> text.txt <span class="token operator">&lt;&lt;</span> <span class="token string">"eof"</span><span class="token comment"># 输入消息，最后一行是 eof 表示退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（3）Linux-中的-amp"><a href="#（3）Linux-中的-amp" class="headerlink" title="（3）Linux 中的 &amp;"></a>（3）Linux 中的 &amp;</h3><p><strong>幕后工作：</strong>在命令结尾加上 &amp; 表示将这个任务放到后台执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 递归的复制文件目录，假如目录很大，需要很久，可以放到后台执行</span><span class="token function">cp</span> -R original/dir/ backup/dir/ <span class="token operator">&amp;</span><span class="token comment"># 回车执行后，会显示一个 进程 ID 号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任务被放到后台执行之后，就可以立即继续在同一个终端上工作了，甚至关闭终端也不影响这个任务的正常执行。需要注意的是，如果要求这个任务输出内容到标准输出中（例如 <code>echo</code> 或 <code>ls</code>），即使使用了 <code>&amp;</code>，也会等待这些输出任务在前台运行完毕。</p><p>当使用 <code>&amp;</code> 将一个进程放置到后台运行的时候，Bash 会提示这个进程的进程 ID。在 Linux 系统中运行的每一个进程都有一个唯一的进程 ID，你可以使用进程 ID 来暂停、恢复或者终止对应的进程，因此进程 ID 是非常重要的。</p><p>当使用该命令启动一个后台进程时，我们可以在当前终端下使用如下几个命令管理后台进程：</p><ul><li><p><code>jobs</code> 命令可以显示当前终端正在运行的进程，包括前台和后台运行的进程。它对每一个正在执行的进程任务分配一个序号（这个序号不是进程 ID），可以使用这些序号来引用各个进程任务：</p></li><li><p><code>fg</code> 命令可以将后台运行的进程任务放到前台运行，这样可以比较方便地进行交互。根据 <code>jobs</code> 命令提供的进程任务序号，再在前面加上 <code>%</code> 符号，就可以把相应的进程任务放到前台运行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将 jobs 显示的标号为 1 的进程放到前台运行</span><span class="token function">fg</span> % <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果这个进程任务是暂停状态，fg 命令可以将它启动起来</p></li><li><p><code>ctrl + z</code> 可以将前台运行的任务暂停，仅仅是暂停而不是终止。当使用 <code>fg</code> 或者 <code>bg</code> 命令将任务重新启动起来的时候，任务会从暂停的地方继续执行。但 <code>sleep</code> 命令是一个特例，<code>sleep</code> 任务被暂停的时间会计算在 <code>sleep</code> 时间之内。因为 <code>sleep</code> 命令依据的是系统时钟的时间，而不是实际运行的时间。也就是说，如果运行了 <code>sleep 30</code> ，然后将任务暂停 30 秒以上，那么任务恢复执行的时候会立即终止并退出。</p></li><li><p><code>bg</code> 命令会将任务防止到后台运行，如果任务是暂停的，也会被启动起来</p></li></ul><h3 id="（4）Linux-的-kill-命令"><a href="#（4）Linux-的-kill-命令" class="headerlink" title="（4）Linux 的 kill 命令"></a>（4）Linux 的 kill 命令</h3><p>前面介绍的几个命令适合在同一个终端中使用，如果启动进程任务的终端关闭了，就无法使用了。</p><p>如果要在另一个终端管理后台进程，就需要使用其他工具，例如 <code>kill</code></p><ul><li><p>暂停后台进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先查进程号</span><span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> 进程名<span class="token comment"># 暂停进程 等同于 ctrl + z</span><span class="token function">kill</span> -s STOP <span class="token operator">&lt;</span>PID<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>把暂停的进程启动：<code>kill -s CONT &lt;PID&gt;</code></p></li><li><p>终止进程：<code>kill -s TERM &lt;PID&gt;</code></p></li><li><p>如果进程不相应 TERM 信号并拒绝退出，可以发送 KILL 信号强制终止进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -s KILL <span class="token operator">&lt;</span>PID<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>强制终止进程可能会有一定的风险，但如果遇到进程无节制消耗资源的情况，这样的信号还是有用的</p></li><li><p>如果不确定进程 ID 是否存在，可以这样 <code>ps x | grep jenkins</code></p></li><li><p>将 <code>ps</code> 和 <code>grep</code> 结合起来的命令：<code>pgrep 字符串</code>，它可以把包含指定字符的进程 ID 列出来</p></li><li><p>加一些参数 ：<code>pgrep -lx 字符串</code>，这样就可以把名称也显示出来，如果想了解更多的细节，可以这样：<code>pgrep -ax</code>，更多请 –help</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Deploy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7_install_docker</title>
      <link href="/2021/07/07/centos7-install-docker/"/>
      <url>/2021/07/07/centos7-install-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>容器的概念在 Linux 中早就有了，并不是 Docker 提出了容器的概念，它是一种轻量级的虚拟化技术，现在常用于打包项目环境，方便我们部署。</p><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><h2 id="1、安装前准备"><a href="#1、安装前准备" class="headerlink" title="1、安装前准备"></a>1、安装前准备</h2><p>LInux 内核版本，官方建议 3.10 以上。</p><ul><li>查看当前内核版本：<code>uname -r</code></li></ul><p><strong>如果不满足条件，可以更新系统：</strong></p><ul><li><code>yum -y update</code>（<strong>谨慎使用</strong>）：升级所有包的同时也升级软件和系统内核</li><li><code>yum -y upgrade</code>：只升级所有包，不升级软件和系统内核</li></ul><p>如果之前安装过 Docker，卸载旧版本：</p><p><code>yum remove docker docker-common docker-selinux docker-engine</code></p><h2 id="2、安装-Docker"><a href="#2、安装-Docker" class="headerlink" title="2、安装 Docker"></a>2、安装 Docker</h2><ul><li><p>安装相关依赖</p><p>yum-utils 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖</p><p><code>yum install -y yum-tuils device-mapper-persistent-data lvm2</code></p></li><li><p>查看已经安装的包 <code>yum list installed</code></p></li><li><p>设置 yum 源，两个都可以使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>选择 Docker 版本并安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看可用版本</span>yum list docker-ce --showduplicates <span class="token operator">|</span> <span class="token function">sort</span> -r<span class="token comment"># 选择一个版本安装。当然也可以默认安装，就是最新版</span>yum <span class="token function">install</span> docker-ce<span class="token comment"># 启动 Docker 并设置开机自启</span>systemctl start dockersystemctl <span class="token builtin class-name">enable</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-install-git</title>
      <link href="/2021/07/06/centos7-install-git/"/>
      <url>/2021/07/06/centos7-install-git/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>CentOS 版本的 Linux，可能默认就带有 git，但是其 yum 仓库中支持的 Git 版本最高是 1.8.1。</p><p>如果直接使用命令 <code>yum -y install git</code>，则安装的是其默认的，我们需要安装最新版的。</p><p>查看版本 默认支持的版本 <code>yum info git</code></p><h2 id="二、安装最新版-Git"><a href="#二、安装最新版-Git" class="headerlink" title="二、安装最新版 Git"></a>二、安装最新版 Git</h2><h3 id="1、卸载旧的-Git、安装新的"><a href="#1、卸载旧的-Git、安装新的" class="headerlink" title="1、卸载旧的 Git、安装新的"></a>1、卸载旧的 Git、安装新的</h3><ul><li><p>如果系统中自带的有 Git，先卸载：<code>yum remove git</code></p></li><li><p>想要安装任意版本的 Git，我们可以使用 <code>wget</code> 或者 <code>curl</code> 工具到对应的仓库中获取 Git</p></li><li><p>推荐网站：<code>https://mirrors.edge.kernel.org/pub/software/scm/git/</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 例如这里安装的 2.18.4 版本的 git</span><span class="token function">wget</span> https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.18.4.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>由于我们没有使用 yum 安装，所以 Git 所需要的依赖只能自己来安装了，感兴趣可以试试查看依赖 </p></li><li><p><code>yum deplist git</code></p></li><li><p>安装依赖及下面的步骤</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装依赖</span>yum <span class="token function">install</span> -y zlib-devel bzip2-devel openssl-devel ncurses-devel gcc perl-ExtUtils-MakeMaker package<span class="token comment"># 解压 Git</span><span class="token function">tar</span> -zxvf ./git-2.18.4.tar.gz<span class="token comment"># 安装</span><span class="token builtin class-name">cd</span> ./git-2.18.4/<span class="token comment"># 这里 /usr/local/git 是我创建的放置 git 的地方 /usr/local/git/git-2.18.4</span>./configure --prefix<span class="token operator">=</span>/usr/local/git all<span class="token comment"># 编译并安装 git 注意这里需要 c++ 的编译器，如果没有就 yum install gcc-c++</span><span class="token comment"># 这里默认安装到 /usr/local 下，可以指定目录，例如</span><span class="token comment"># make install /usr/local/mygit</span><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2、Git-相关配置"><a href="#2、Git-相关配置" class="headerlink" title="2、Git 相关配置"></a>2、Git 相关配置</h3><ul><li><p>配置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">${JAVA_HOME}</span>/bin:<span class="token variable">${MAVEN_HOME}</span>/bin:/usr/local/git/bin<span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果想要卸载 Git，安装其他的版本，可以这样：<code>yum remove git</code></p></li><li><p>配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置基本信息</span><span class="token function">git</span> config --global user.name <span class="token string">"username"</span><span class="token function">git</span> config --global user.email QQ邮箱<span class="token comment"># 查看配置</span><span class="token function">git</span> config --list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="三、补充小知识"><a href="#三、补充小知识" class="headerlink" title="三、补充小知识"></a>三、补充小知识</h2><blockquote><p>Linux 安装软件源码包的流程：</p></blockquote><p>一般会涉及到三个步骤：</p><p>一般会涉及到三个步骤：</p><ol><li><p><code>./configure</code></p><ul><li><p>该步骤主要用来检测系统的配置、环境以及相关依赖，如果缺少相关依赖，该脚本会终止执行，软件安装失败</p><p>当该脚本执行完成之后，会生成一个 Makefile 文件，该文件规定了用什么编译器、编译参数等等，描述了文件编译的互相依赖关系</p></li></ul></li><li><p><code>make</code></p><p>该步骤主要用来编译源代码，make 命令会从 Makefile 文件中读取相关指令，编译完成后会生成可执行文件</p></li><li><p><code>make install</code></p><p>该步骤主要用来安装软件，make install 命令会从 Makefile 文件中读取相关指令，然后将软件安装到指定的位置， 默认安装位置是 <code>/usr/local</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-install-jdk</title>
      <link href="/2021/07/06/centos7-install-jdk/"/>
      <url>/2021/07/06/centos7-install-jdk/</url>
      
        <content type="html"><![CDATA[<h2 id="一、卸载-Open-JDK"><a href="#一、卸载-Open-JDK" class="headerlink" title="一、卸载 Open-JDK"></a>一、卸载 Open-JDK</h2><p>有的 Linux 系统可能已经安装了 open-jdk，它是 jdk 开源之前的版本，已经不在维护了，我们可以卸载它</p><ul><li><p>使用命令 <code>rpm -qa | grep java</code> 查询系统中和 java 相关的文件，一个个删除</p></li><li><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64<span class="token function">rpm</span> -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64<span class="token function">rpm</span> -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64<span class="token function">rpm</span> -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查是否已经删除成功：输入 <strong>java -version</strong></p></li><li><p>如果没有删除完，就使用 yum 删除：<strong>yum -y remove</strong></p></li></ul><h2 id="二、安装稳定的-JDK"><a href="#二、安装稳定的-JDK" class="headerlink" title="二、安装稳定的 JDK"></a>二、安装稳定的 JDK</h2><p>官网：<a href="http://www.oracle.com/">http://www.oracle.com</a></p><p>下载相应的 Linux 版本后，做好备份，开始解压</p><p>可以将 jdk 复制一份放到 <code>/usr/local/src</code> 做备份</p><p>在 <code>/usr/java</code> 中解压 jdk（创建一个 java 目录）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> -zxvf jdk-8u281-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有权限就：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">755</span> jdk-8u281-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果实在不行，就进入 root 用户进行操作</p><p>解压完成后开始设置系统环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span class="token comment"># 最后面添加下列</span><span class="token comment"># java environment</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/java/jdk1.8.0_281<span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">${JAVA_HOME}</span>/jre/lib/rt.jar:<span class="token variable">${JAVA_HOME}</span>/lib/dt.jar:<span class="token variable">${JAVA_HOME}</span>/lib/tools.jar<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">${JAVA_HOME}</span>/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置完成后，重新编译配置文件：<code>source /etc/profile</code></p><p>最后检查是否成功安装：<code>java -version</code> 如何输出了 java 的版本信息就说明成功了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-install-mysql</title>
      <link href="/2021/07/06/centos7-install-mysql/"/>
      <url>/2021/07/06/centos7-install-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="一、官方推荐"><a href="#一、官方推荐" class="headerlink" title="一、官方推荐"></a>一、官方推荐</h2><p>官方文档：<a href="https://dev.mysql.com/doc/mysql-installation-excerpt/5.6/en/linux-installation-yum-repo.html">https://dev.mysql.com/doc/mysql-installation-excerpt/5.6/en/linux-installation-yum-repo.html</a>    </p><p>根据官网推荐安装 <code>yum 仓库</code></p><p>注意自己的 Linux 版本，例如我用的 CentOS7 7.x 可以下载对应的 Oracle Linux 7 版本的 yum 仓库配置</p><p>下载地址：<a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a></p><p>然后输入以下命令更新自己的本地 yum 仓库列表：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum localinstall mysql57-community-release-el7-<span class="token punctuation">{</span>version-number<span class="token punctuation">}</span>.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以输入以下命令检查是否成功更新本地 yum 仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum repolist enabled <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"mysql.*-community.*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新成功后可以直接安装，官方下载的 yum 仓库配置，默认开启当前 GA 版本的支持，如果想更换版本可以这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先查看哪些版本被启用</span>shell<span class="token operator">&gt;</span> yum repolist all <span class="token operator">|</span> <span class="token function">grep</span> mysql<span class="token comment"># 然后可以更换版本, 这里假如当前GA版本为 5.7，想要更换为 5.6 </span>shell<span class="token operator">&gt;</span> <span class="token function">sudo</span> yum-config-manager --disable mysql57-communityshell<span class="token operator">&gt;</span> <span class="token function">sudo</span> yum-config-manager --enable mysql56-community<span class="token comment"># 一般都不用更换版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了使用命令更改，还可以直接找到相关文件进行修改：</p><p> <code>/etc/yum.repos.d/mysql-community.repo</code> </p><p>如果是 EL8 版本的内核，还需要考虑其他情况，具体参见官方文档</p><h2 id="二、默认安装（推荐）"><a href="#二、默认安装（推荐）" class="headerlink" title="二、默认安装（推荐）"></a>二、默认安装（推荐）</h2><p>安装命令：</p><p>两种方式，可以安装到默认的位置，也可以自定义（不推荐，比较麻烦）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> mysql-community-server<span class="token comment"># 自定义</span><span class="token function">sudo</span> yum -c /etc/yum --releasever<span class="token operator">=</span>/ --installroot<span class="token operator">=</span>/usr/local/mysql-8.0 -y <span class="token function">install</span> mysql-community-server<span class="token comment"># 参数</span><span class="token comment"># -c 是读取 yum 的配置文件路径</span><span class="token comment"># --releasever=/</span><span class="token comment">#  我们可以在 yum 配置源的文件中找到很多这样的字符 $releasever 和 $basearch</span><span class="token comment">#$releasever 代表当前系统的发行版本，可以通过 rpm -qi centos-release</span><span class="token comment">#$basearch 是我们的系统硬件架构（CPU 指令集），可以使用命令 arch 得到</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yum 虽然很好的解决了 软件依赖 的问题，但是不能查看软件的位置，我们可以使用 rpm 来查看相关信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看软件包安装的目录和文件（包括了可执行程序、配置文件和帮助文档）。</span><span class="token function">rpm</span> -ql mysql-community-server<span class="token comment"># 查看已安装软件包的详细信息。 和 yum info 有点类似</span><span class="token function">rpm</span> -qi mysql-community-server<span class="token comment"># 查看已安装软件包的配置</span><span class="token function">rpm</span> -qc mysql-community-server <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到默认安装后，mysql 的相关文件的位置是严格遵守 Linux 目录的 <code>FHS</code>。</p><h3 id="1、开启-MySQL-服务"><a href="#1、开启-MySQL-服务" class="headerlink" title="1、开启 MySQL 服务"></a>1、开启 MySQL 服务</h3><p>这里要提一下：</p><p>MySQL 官方推荐创建 mysql 用户和用户组来管理 mysql 服务。</p><p>我们采用的 yum 方式安装 mysql-community-server ，已经默认给我们创建好了对应的系统账户和组，所以可以不用管这一步。</p><p>使用 <code>cat /etc/passwd | grep mysql</code> 可以看到 mysql 系统账户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建组</span><span class="token function">groupadd</span> mysql<span class="token comment"># 创建用户</span><span class="token function">useradd</span> -r -g mysql -s /bin/false mysql<span class="token comment"># 注意，我们只需要创建一个账户用于管理 mysql 服务，所以可以这样做</span><span class="token comment"># -r 创建系统账户，不会给它生成家目录</span><span class="token comment"># -g 属于 mysql 组</span><span class="token comment"># -s 指定该系统账户持有的 shell 为 /bin/false</span><span class="token comment">#    </span><span class="token comment"># 最后还需要给相应的mysql文件设置权限：chmod 750 mysql-files</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在可以开启服务了：</p><p>分为两种情况：</p><ul><li><p>初始化随机密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认安装，环境变量已经配置好了</span>mysqld --initialize --user<span class="token operator">=</span>mysql<span class="token comment"># 使用 systemctl 开启服务</span>systemctl start mysqld<span class="token comment"># 查看初始化后随机生成的密码</span><span class="token function">tail</span> /var/log/mysqld.log <span class="token operator">|</span> <span class="token function">grep</span> temporary<span class="token comment"># 可以看到</span><span class="token punctuation">[</span>Note<span class="token punctuation">]</span> <span class="token punctuation">[</span>MY-010454<span class="token punctuation">]</span> <span class="token punctuation">[</span>Server<span class="token punctuation">]</span> A temporary password is generated <span class="token keyword">for</span> root@localhost: <span class="token operator">&lt;</span>6za-KXb<span class="token operator">&amp;</span>j<span class="token comment">#p</span><span class="token comment"># 后面就是密码</span><span class="token comment"># 登录数据库并修改密码</span>mysql -u root -penter password: （注：这里输入密码不显示，输入刚刚的随机密码就好了）<span class="token comment"># 登录成功后修改密码才能执行下一步操作, 这里我设置密码为 123456</span>ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'123456'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不生成密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果想不生成随机密码，可以使用如下命令初始化数据目录</span>mysqld --initialize-insecure --user<span class="token operator">=</span>mysql<span class="token comment"># 开启服务后，登录时使用</span>mysql -u root --skip-password<span class="token comment"># 然后修改密码</span>ALTER <span class="token environment constant">USER</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'root-password'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="2、修改-MySQL-配置文件"><a href="#2、修改-MySQL-配置文件" class="headerlink" title="2、修改 MySQL 配置文件"></a>2、修改 MySQL 配置文件</h3><p>默认安装一般 MySQL 服务启动时加载的配置参数在 <code>/etc/my.cnf</code> 文件中，我们可以修改其中的配置：</p><p>下面列举最简单的一种情况，以方便我们在 Windows 中使用工具远程连接服务器数据库：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">client</span><span class="token punctuation">]</span></span><span class="token key attr-name">port</span><span class="token punctuation">=</span><span class="token value attr-value">3306</span><span class="token key attr-name">socket</span><span class="token punctuation">=</span><span class="token value attr-value">/tmp/mysql.sock</span><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span><span class="token key attr-name">port</span><span class="token punctuation">=</span><span class="token value attr-value">3306</span><span class="token key attr-name">socket</span><span class="token punctuation">=</span><span class="token value attr-value">/tmp/mysql.sock</span><span class="token key attr-name">key_buffer_size</span><span class="token punctuation">=</span><span class="token value attr-value">16M</span><span class="token key attr-name">max_allowed_packet</span><span class="token punctuation">=</span><span class="token value attr-value">128M</span><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">mysqldump</span><span class="token punctuation">]</span></span>quick<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为我们要使用 root 账户连接，所以需要了解一下 MySQL 中账户访问的相关知识：</p><ul><li><p>mysql 中账户名由两部分组成 ‘user_name‘@’host_name’</p></li><li><p>在 MySQL 中，不仅要指定谁可以连接，还要指定可以从什么地方进行连接，这意味着，可以有拥有相同名字、但会从不同位置连接服务器的两个用户</p><p>进入 MySQL 命令行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">use mysql<span class="token punctuation">;</span><span class="token keyword">select</span> user, <span class="token function">host</span> from user<span class="token punctuation">;</span><span class="token comment"># 可以看到 root 的 host 是 localhost</span><span class="token comment"># 这意味着 root 用户只能从本机访问 mysql 服务</span><span class="token comment"># 我们现在想在远程访问就需要做一些修改</span><span class="token comment"># 为了方便，我这里直接将 访问地址 改为通配符 % ，允许任何地方连接</span><span class="token comment"># 如果是实际的服务器，可能会带来风险，请视实际情况而定</span>update user <span class="token builtin class-name">set</span> <span class="token assign-left variable">host</span><span class="token operator">=</span><span class="token string">'%'</span> where <span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span class="token comment"># 刷新权限</span>flush privileges<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3、开放端口和服务"><a href="#3、开放端口和服务" class="headerlink" title="3、开放端口和服务"></a>3、开放端口和服务</h3><p>由于 centos 7 拥有防火墙，如果我们想要远程访问 MySQL 服务，就需要开放相应的端口和服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 最简单的情况，关闭防火墙，并禁用它</span>systemctl stop firewalldsystemctl disable firewalld<span class="token comment"># 安全的情况</span><span class="token comment"># 我们在 my.cnf 中指定了MySQL使用的端口</span><span class="token comment"># 开发端口</span>firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span><span class="token number">3306</span>/tcp --permanent<span class="token comment"># 开放服务</span>firewall-cmd --zone<span class="token operator">=</span>public --add-service<span class="token operator">=</span>mysql --permanent<span class="token comment"># 重新加载</span>firewall-cmd --reload<span class="token comment"># 查看结果</span>firewall-cmd --list-portfirewall-cmd --list-service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、测试远程连接"><a href="#4、测试远程连接" class="headerlink" title="4、测试远程连接"></a>4、测试远程连接</h3><p>自己使用工具进行远程连接测试</p><h2 id="三、自定义安装"><a href="#三、自定义安装" class="headerlink" title="三、自定义安装"></a>三、自定义安装</h2><h3 id="1、命令"><a href="#1、命令" class="headerlink" title="1、命令"></a>1、命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum -c /etc/yum --releasever<span class="token operator">=</span>/ --installroot<span class="token operator">=</span>/usr/local/mysql_8.0 -y <span class="token function">install</span> mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我在这里安装到 <code>/usr/local/mysql_8.0</code> 下面，查看目录后可以发现，在该目录下的所有目录和根路径下面的一样，下面列举出常用目录：</p><ul><li>可以发现 <code>mysql_8.0/bin/mysql</code> 和 <code>mysql_8.0/usr/bin/mysql</code>，以及 <code>mysql_8.0/sbin/mysqld</code> 和 <code>mysql_8.0/usr/sbin/mysqld</code>，都是 <strong>硬链接</strong> 的关系</li><li>一些常用的命令现在感觉有些冗余，可见虽然使用了 安装路径 后便于管理，但是使用起来感觉不太方便，所以还是推荐默认安装</li><li>而且现在还需要配置环境变量</li></ul><h3 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h3><p>设置 mysql <strong>系统环境变量</strong></p><p>Linux 推荐我们在 <code>/etc/profile.d/</code> 目录下通过编写 mysql.sh 来配置其环境变量，因为 Linux 启动后会读取  <code>/etc/profile</code>  文件，然后根据其中的内容又会调用 <code>/etc/profile.d/</code> 目录下的脚本文件，但是又要花时间学习 shell 编写脚本。为了方便还是直接在 <code>/etc/profile</code> 中编写环境变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果 /etc/profile 不可以编写，先更改权限 chmod u+w /etc/profile</span><span class="token comment"># 最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/local/mysql_8.0/bin:/usr/local/mysql_8.0/sbin<span class="token comment"># 使其生效</span><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、关于配置文件"><a href="#3、关于配置文件" class="headerlink" title="3、关于配置文件"></a>3、关于配置文件</h3><p>Linux 中的 MySQL 配置文件的名称为 <code>my.cnf</code>，采用自定义安装，可以在 <code>/etc/my.cnf</code> 和 <code>/usr/local/mysql_8.0/etc/my.cnf</code> 找到，我们只需关注 mysql 安装路径下的配置文件就好了。</p><p>感兴趣可以到官网看看：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html">https://dev.mysql.com/doc/refman/8.0/en/server-configuration-defaults.html</a></p><h3 id="4、自定义路径的坑"><a href="#4、自定义路径的坑" class="headerlink" title="4、自定义路径的坑"></a>4、自定义路径的坑</h3><p>可能会遇到这个错误：</p><p><code>Cannot find a valid baseurl for repo: base/$releasever/x86_64</code></p><ul><li><strong>这里是由于我指定了安装路径但是没有指定内核版本导致的问题，加上 –releasever=/ 就好了，当然了解一下怎么换源也不错</strong></li><li>**在虚拟机中测试的时候，由于我设置静态 ip 的时候配置 dns 没有正确配置，也报了这个错，正确配置应该是这样的 ** <code>DNS1=114.114.114.114</code>，第二个 DNS2 可加可不加，记住要加 DNS1， OvO</li></ul><p>现在尝试配置其他源：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 可以先查看默认的源</span><span class="token function">cat</span> /etc/yum.repos.d/CentOS-Base.repo <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>base<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - Base<span class="token assign-left variable">mirrorlist</span><span class="token operator">=</span>http://mirrorlist.centos.org/?release<span class="token operator">=</span><span class="token variable">$releasever</span><span class="token operator">&amp;</span><span class="token assign-left variable">arch</span><span class="token operator">=</span><span class="token variable">$basearch</span><span class="token operator">&amp;</span><span class="token assign-left variable">repo</span><span class="token operator">=</span>os<span class="token operator">&amp;</span><span class="token assign-left variable">infra</span><span class="token operator">=</span><span class="token variable">$infra</span><span class="token comment">#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span><span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<span class="token comment">#released updates </span><span class="token punctuation">[</span>updates<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - Updates<span class="token assign-left variable">mirrorlist</span><span class="token operator">=</span>http://mirrorlist.centos.org/?release<span class="token operator">=</span><span class="token variable">$releasever</span><span class="token operator">&amp;</span><span class="token assign-left variable">arch</span><span class="token operator">=</span><span class="token variable">$basearch</span><span class="token operator">&amp;</span><span class="token assign-left variable">repo</span><span class="token operator">=</span>updates<span class="token operator">&amp;</span><span class="token assign-left variable">infra</span><span class="token operator">=</span><span class="token variable">$infra</span><span class="token comment">#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/</span><span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<span class="token comment">#additional packages that may be useful</span><span class="token punctuation">[</span>extras<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - Extras<span class="token assign-left variable">mirrorlist</span><span class="token operator">=</span>http://mirrorlist.centos.org/?release<span class="token operator">=</span><span class="token variable">$releasever</span><span class="token operator">&amp;</span><span class="token assign-left variable">arch</span><span class="token operator">=</span><span class="token variable">$basearch</span><span class="token operator">&amp;</span><span class="token assign-left variable">repo</span><span class="token operator">=</span>extras<span class="token operator">&amp;</span><span class="token assign-left variable">infra</span><span class="token operator">=</span><span class="token variable">$infra</span><span class="token comment">#baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/</span><span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<span class="token comment">#additional packages that extend functionality of existing packages</span><span class="token punctuation">[</span>centosplus<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - Plus<span class="token assign-left variable">mirrorlist</span><span class="token operator">=</span>http://mirrorlist.centos.org/?release<span class="token operator">=</span><span class="token variable">$releasever</span><span class="token operator">&amp;</span><span class="token assign-left variable">arch</span><span class="token operator">=</span><span class="token variable">$basearch</span><span class="token operator">&amp;</span><span class="token assign-left variable">repo</span><span class="token operator">=</span>centosplus<span class="token operator">&amp;</span><span class="token assign-left variable">infra</span><span class="token operator">=</span><span class="token variable">$infra</span><span class="token comment">#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/</span><span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单分析以下每个源（源都以 [] 括住）中主要的配置信息：以 [base] 为例</p><ul><li>[base] 源</li><li>name：说明当前软件源的意义，不重要</li><li>mirrorlist：列出这个软件源可以使用的镜像站，如果不想使用，可以注释掉</li><li><strong>baseurl</strong>：这个最重要，后面接的是这个软件源的实际地址，mirrorlist 是 YUM 程序自动识别镜像站，baseurl 则是指定固定的软件源网址</li><li>enable=1：让该软件源被启用，不想启用就设置为 0</li><li>gpgcheck=1：指定要查看 RPM 的数字签名</li><li>gpgkey=xxx：就是数字签名的公钥文件所在位置，使用默认值即可</li></ul><p>例如改为阿里云源：</p><p>官网：<a href="http://mirrors.aliyun.com/repo/">http://mirrors.aliyun.com/repo/</a></p><p>我们可以下载官方的 yum 源配置，windows 下直接下载文件，或者在 Linux 的图形界面访问官网。</p><p>我习惯于使用 命令行 ，所以使用如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 有个插件 fastestmirror 是用于测试当有多个源时选择速度最快的那个，可禁可不禁</span><span class="token comment"># 我们对 yum 的源配置文件做备份就好了</span><span class="token function">cp</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<span class="token comment"># 获取 阿里云 的 repo，直接覆盖就好了，注意内核版本</span><span class="token function">wget</span> -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<span class="token comment"># Tip：我没有用这种方法，而是在原来的文件中直接将所有源禁用，设置 enable=0</span><span class="token comment"># 然后再去阿里云对应的 repo 文件中复制所有配置源信息到目标文件中</span><span class="token comment"># 最后启用 阿里云 的源，设置 enable=1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后清除缓存再生成缓存：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 清除缓存</span>yum clean all<span class="token function">rm</span> -rf /var/cache/yum<span class="token comment"># 重新生成缓存</span>yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、自定义安装配置"><a href="#5、自定义安装配置" class="headerlink" title="5、自定义安装配置"></a>5、自定义安装配置</h3><p>参考官网：<a href="https://dev.mysql.com/doc/refman/8.0/en/data-directory-initialization.html">https://dev.mysql.com/doc/refman/8.0/en/data-directory-initialization.html</a></p><p>官方推荐创建 mysql 组 和 用户 来管理 mysql，允许该用户连接数据库服务器，远程安全连接可以使用 <code>mysql_ssl-rsa_setup</code> 程序创建默认的 SSL 和 RSA 文件。不过我们是学习就算了</p><p>tip：在MySQL 8.0中，默认的身份验证插件已从更改 <code>mysql_native_password</code>为 <code>caching_sha2_password</code>，并且 默认情况下<code>'root'@'localhost'</code>使用管理帐户<code>caching_sha2_password</code>。</p><h2 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h2><p>my.conf 需要慢慢调试找到最优配置：</p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">client</span><span class="token punctuation">]</span></span>    <span class="token key attr-name">port</span> <span class="token punctuation">=</span> <span class="token value attr-value">3306</span><span class="token key attr-name">socket</span> <span class="token punctuation">=</span> <span class="token value attr-value">/tmp/mysql.sock</span><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">mysqld</span><span class="token punctuation">]</span></span><span class="token key attr-name">user</span> <span class="token punctuation">=</span> <span class="token value attr-value">mysql    --- 表示MySQL的管理用户</span><span class="token key attr-name">port</span> <span class="token punctuation">=</span> <span class="token value attr-value">3306    --- 端口</span><span class="token key attr-name">socket</span> <span class="token punctuation">=</span> <span class="token value attr-value">/tmp/mysql.sock    -- 启动的sock文件</span><span class="token key attr-name">log-bin</span> <span class="token punctuation">=</span> <span class="token value attr-value">/data/mysql-bin</span><span class="token key attr-name">basedir</span> <span class="token punctuation">=</span> <span class="token value attr-value">/usr/local/mysql</span><span class="token key attr-name">datadir</span> <span class="token punctuation">=</span> <span class="token value attr-value">/data/</span><span class="token key attr-name">pid-file</span> <span class="token punctuation">=</span> <span class="token value attr-value">/data/mysql.pid</span><span class="token key attr-name">user</span> <span class="token punctuation">=</span> <span class="token value attr-value">mysql</span><span class="token key attr-name">bind-address</span> <span class="token punctuation">=</span> <span class="token value attr-value">0.0.0.0</span><span class="token key attr-name">server-id</span> <span class="token punctuation">=</span> <span class="token value attr-value">1 #表示是本机的序号为1,一般来讲就是master的意思</span>skip-name-resolve<span class="token comment"># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，</span><span class="token comment"># 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</span><span class="token comment">#skip-networking</span><span class="token key attr-name">back_log</span> <span class="token punctuation">=</span> <span class="token value attr-value">600</span><span class="token comment"># MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，</span><span class="token comment"># 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。</span><span class="token comment"># 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，</span><span class="token comment"># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</span><span class="token comment"># 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。</span><span class="token comment"># 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。</span><span class="token key attr-name">max_connections</span> <span class="token punctuation">=</span> <span class="token value attr-value">1000</span><span class="token comment"># MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。</span><span class="token key attr-name">max_connect_errors</span> <span class="token punctuation">=</span> <span class="token value attr-value">6000</span><span class="token comment"># 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。</span><span class="token key attr-name">open_files_limit</span> <span class="token punctuation">=</span> <span class="token value attr-value">65535</span><span class="token comment"># MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，</span><span class="token comment"># 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。</span><span class="token key attr-name">table_open_cache</span> <span class="token punctuation">=</span> <span class="token value attr-value">128</span><span class="token comment"># MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64</span><span class="token comment"># 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；</span><span class="token comment"># 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上</span><span class="token key attr-name">max_allowed_packet</span> <span class="token punctuation">=</span> <span class="token value attr-value">4M</span><span class="token comment"># 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。</span><span class="token comment"># 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。</span><span class="token key attr-name">binlog_cache_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">1M</span><span class="token comment"># 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K</span><span class="token key attr-name">max_heap_table_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变</span><span class="token key attr-name">tmp_table_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">16M</span><span class="token comment"># MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。</span><span class="token comment"># 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。</span><span class="token comment"># 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果</span><span class="token key attr-name">read_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">2M</span><span class="token comment"># MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。</span><span class="token comment"># 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能</span><span class="token key attr-name">read_rnd_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，</span><span class="token comment"># MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</span><span class="token key attr-name">sort_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。</span><span class="token comment"># 如果不能，可以尝试增加sort_buffer_size变量的大小</span><span class="token key attr-name">join_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享</span><span class="token key attr-name">thread_cache_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8</span><span class="token comment"># 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，</span><span class="token comment"># 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，</span><span class="token comment"># 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)</span><span class="token comment"># 根据物理内存设置规则如下：</span><span class="token comment"># 1G  —&gt; 8</span><span class="token comment"># 2G  —&gt; 16</span><span class="token comment"># 3G  —&gt; 32</span><span class="token comment"># 大于3G  —&gt; 64</span><span class="token key attr-name">query_cache_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment">#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，</span><span class="token comment"># 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。</span><span class="token comment"># 通过检查状态值'Qcache_%'，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，</span><span class="token comment"># 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，</span><span class="token comment"># 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲</span><span class="token key attr-name">query_cache_limit</span> <span class="token punctuation">=</span> <span class="token value attr-value">2M</span><span class="token comment">#指定单个查询能够使用的缓冲区大小，默认1M</span><span class="token key attr-name">key_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">4M</span><span class="token comment">#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，</span><span class="token comment"># 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，</span><span class="token comment"># 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，</span><span class="token comment"># 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE 'key_read%'获得)。注意：该参数值设置的过大反而会是服务器整体效率降低</span><span class="token key attr-name">ft_min_word_len</span> <span class="token punctuation">=</span> <span class="token value attr-value">4</span><span class="token comment"># 分词词汇最小长度，默认4</span><span class="token key attr-name">transaction_isolation</span> <span class="token punctuation">=</span> <span class="token value attr-value">REPEATABLE-READ</span><span class="token comment"># MySQL支持4种事务隔离级别，他们分别是：</span><span class="token comment"># READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</span><span class="token comment"># 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED</span><span class="token key attr-name">log_bin</span> <span class="token punctuation">=</span> <span class="token value attr-value">mysql-bin</span><span class="token key attr-name">binlog_format</span> <span class="token punctuation">=</span> <span class="token value attr-value">mixed</span><span class="token key attr-name">expire_logs_days</span> <span class="token punctuation">=</span> <span class="token value attr-value">30 #超过30天的binlog删除</span><span class="token key attr-name">log_error</span> <span class="token punctuation">=</span> <span class="token value attr-value">/data/mysql/mysql-error.log #错误日志路径</span><span class="token key attr-name">slow_query_log</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span><span class="token key attr-name">long_query_time</span> <span class="token punctuation">=</span> <span class="token value attr-value">1 #慢查询时间 超过1秒则为慢查询</span><span class="token key attr-name">slow_query_log_file</span> <span class="token punctuation">=</span> <span class="token value attr-value">/data/mysql/mysql-slow.log</span><span class="token key attr-name">performance_schema</span> <span class="token punctuation">=</span> <span class="token value attr-value">0</span>explicit_defaults_for_timestamp<span class="token comment">#lower_case_table_names = 1 #不区分大小写</span>skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启<span class="token key attr-name">default-storage-engine</span> <span class="token punctuation">=</span> <span class="token value attr-value">InnoDB #默认存储引擎</span><span class="token key attr-name">innodb_file_per_table</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span><span class="token comment"># InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间</span><span class="token comment"># 独立表空间优点：</span><span class="token comment"># 1．每个表都有自已独立的表空间。</span><span class="token comment"># 2．每个表的数据和索引都会存在自已的表空间中。</span><span class="token comment"># 3．可以实现单表在不同的数据库中移动。</span><span class="token comment"># 4．空间可以回收（除drop table操作处，表空不能自已回收）</span><span class="token comment"># 缺点：</span><span class="token comment"># 单表增加过大，如超过100G</span><span class="token comment"># 结论：</span><span class="token comment"># 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files</span><span class="token key attr-name">innodb_open_files</span> <span class="token punctuation">=</span> <span class="token value attr-value">500</span><span class="token comment"># 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300</span><span class="token key attr-name">innodb_buffer_pool_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">64M</span><span class="token comment"># InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.</span><span class="token comment"># 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.</span><span class="token comment"># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</span><span class="token comment"># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</span><span class="token comment"># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</span><span class="token comment"># 所以不要设置的太高.</span><span class="token key attr-name">innodb_write_io_threads</span> <span class="token punctuation">=</span> <span class="token value attr-value">4</span><span class="token key attr-name">innodb_read_io_threads</span> <span class="token punctuation">=</span> <span class="token value attr-value">4</span><span class="token comment"># innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4</span><span class="token comment"># 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64</span><span class="token key attr-name">innodb_thread_concurrency</span> <span class="token punctuation">=</span> <span class="token value attr-value">0</span><span class="token comment"># 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量</span><span class="token key attr-name">innodb_purge_threads</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span><span class="token comment"># InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。</span><span class="token comment"># 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单</span><span class="token comment"># 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1</span><span class="token key attr-name">innodb_flush_log_at_trx_commit</span> <span class="token punctuation">=</span> <span class="token value attr-value">2</span><span class="token comment"># 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。</span><span class="token comment"># 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1</span><span class="token comment"># 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。</span><span class="token comment"># 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。</span><span class="token comment"># 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘</span><span class="token comment"># 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。</span><span class="token comment"># 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</span><span class="token comment"># 总结</span><span class="token comment"># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</span><span class="token key attr-name">innodb_log_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">2M</span><span class="token comment"># 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间</span><span class="token key attr-name">innodb_log_file_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">32M</span><span class="token comment"># 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间</span><span class="token key attr-name">innodb_log_files_in_group</span> <span class="token punctuation">=</span> <span class="token value attr-value">3</span><span class="token comment"># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</span><span class="token key attr-name">innodb_max_dirty_pages_pct</span> <span class="token punctuation">=</span> <span class="token value attr-value">90</span><span class="token comment"># innodb主线程刷新缓存池中的数据，使脏数据比例小于90%</span><span class="token key attr-name">innodb_lock_wait_timeout</span> <span class="token punctuation">=</span> <span class="token value attr-value">120</span> <span class="token comment"># InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒</span><span class="token key attr-name">bulk_insert_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。</span><span class="token key attr-name">myisam_sort_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token comment"># MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区</span><span class="token key attr-name">myisam_max_sort_file_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">10G</span><span class="token comment"># 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出</span><span class="token key attr-name">myisam_repair_threads</span> <span class="token punctuation">=</span> <span class="token value attr-value">1</span><span class="token comment"># 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内) </span><span class="token key attr-name">interactive_timeout</span> <span class="token punctuation">=</span> <span class="token value attr-value">28800</span><span class="token comment"># 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）</span><span class="token key attr-name">wait_timeout</span> <span class="token punctuation">=</span> <span class="token value attr-value">28800</span><span class="token comment"># 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，</span><span class="token comment"># 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）</span><span class="token comment"># MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，</span><span class="token comment"># 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，</span><span class="token comment"># 最终肯定会达到MySQL Server的连接上限数，这会报'too many connections'的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。</span><span class="token comment"># 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，</span><span class="token comment"># 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。</span><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">mysqldump</span><span class="token punctuation">]</span></span>quick<span class="token key attr-name">max_allowed_packet</span> <span class="token punctuation">=</span> <span class="token value attr-value">16M #服务器发送和接受的最大包长度</span><span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">myisamchk</span><span class="token punctuation">]</span></span><span class="token key attr-name">key_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token key attr-name">sort_buffer_size</span> <span class="token punctuation">=</span> <span class="token value attr-value">8M</span><span class="token key attr-name">read_buffer</span> <span class="token punctuation">=</span> <span class="token value attr-value">4M</span><span class="token key attr-name">write_buffer</span> <span class="token punctuation">=</span> <span class="token value attr-value">4M</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-install-redis</title>
      <link href="/2021/07/06/centos7-install-redis/"/>
      <url>/2021/07/06/centos7-install-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Windows-下安装-Redis"><a href="#一、Windows-下安装-Redis" class="headerlink" title="一、Windows 下安装 Redis"></a>一、Windows 下安装 Redis</h2><p>先去官网下载源文件压缩包，解压到自己创建的指定目录下，建议目录绝对路径中不要出现中文。</p><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>使用 cmd，将 Redis 作为服务安装到 Windows 中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入 redis 解压目录下redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 卸载服务redis-server --service-uninstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、查看版本"><a href="#2、查看版本" class="headerlink" title="2、查看版本"></a>2、查看版本</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">redis-server --version # 或者 redis-server -vredis-cli --version # 或 redis-cli -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>严格上说：通过　redis-cli 得到的结果应该是redis-cli 的版本，但是 redis-cli 和redis-server，一般都是从同一套源码编译出的。所以应该是一样的。</p><h2 id="二、Linux-中安装-Redis"><a href="#二、Linux-中安装-Redis" class="headerlink" title="二、Linux 中安装 Redis"></a>二、Linux 中安装 Redis</h2><h3 id="1、两种方式"><a href="#1、两种方式" class="headerlink" title="1、两种方式"></a>1、两种方式</h3><ul><li>从官网下载源文件压缩包，然后通过工具或协议上传到 Linux 服务器</li><li>使用 Linux 中的命令工具直接拉取</li></ul><h3 id="2、前置条件"><a href="#2、前置条件" class="headerlink" title="2、前置条件"></a>2、前置条件</h3><ul><li><p>安装 C++ 的编译器：CentOS 中，C 的编译器是 gcc，C++ 的编译器是 g++</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum -y install gcc-c++# 出现错误，可以多看看 redis 的 ReadMe.md 文件make MALLOC=libc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3、开始安装"><a href="#3、开始安装" class="headerlink" title="3、开始安装"></a>3、开始安装</h3><p>在此之前，我们应该了解 Linux 的各个目录代表的含义。</p><p>我习惯于将自己下载的软件解压并安装到 <code>/usr/local/ </code> 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入目录cd /usr/local# 先到官网看看长期稳定版本的版本号，wget https://download.redis.io/releases/redis-6.2.3.tar.gz# 解压tar xzf redis-6.2.3.tar.gz# 解压后，压缩包可以自己备份以下，以便以后使用，也可以删掉# 进入解压后的目录下，开始编译源文件cd ./redis-6.2.3make# 切换到/usr/local/redis-6.2.3/src目录cd src/# 开始安装 Redismake install# 安装完成之后，我们可以创建两个文件夹用户存放 配置文件 和 常用的命令cd ../mkdir etcmkdir bin# 备份配置文件cp redis.conf ./etc/# 转移常用命令mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-cli redis-server redis-sentinel /usr/local/redis-6.2.3/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 修改配置文件cd ./excvim redis.conf# redis.conf主要修改以下 4 点：# 1.将 daemonize no 改为 daemonize yes，表示需要在后台运行# 2. 将 bind 127.0.0.1 这一行注释掉，如果不需要远程连接服务器，这个可以不用注释，它的意思是只允许本机访问# 3. 将 protect-mode yes 改为 protect-mode no，如果不远程连接则不需要注释# 4. 添加 requirepass 123456 设置密码(默认密码为空)，如果只是在本机测试，也不需要设置密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、启动-Redis-服务并测试"><a href="#5、启动-Redis-服务并测试" class="headerlink" title="5、启动 Redis 服务并测试"></a>5、启动 Redis 服务并测试</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 依据指定配置文件启动 Rediscd /usr/local/redis-6.2.3/binredis-server ../etc/redis.conf# 使用 redis-cli 连接本机 Redis 服务，默认端口 6379redis-cli# 认证后测试auth 123456set name naivekyoget name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>draft-test</title>
      <link href="/2021/07/06/draft-test/"/>
      <url>/2021/07/06/draft-test/</url>
      
        <content type="html"><![CDATA[<h2 id="一、测试草稿-发布"><a href="#一、测试草稿-发布" class="headerlink" title="一、测试草稿-发布"></a>一、测试草稿-发布</h2><p>测试流程：</p><ol><li>创建草稿</li><li>发布草稿</li><li>查看结果</li></ol><h2 id="二、测试修改-发布"><a href="#二、测试修改-发布" class="headerlink" title="二、测试修改-发布"></a>二、测试修改-发布</h2><p>测试流程：</p><ol><li>修改已有文件</li><li>发布</li><li>查看结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> BlogTest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/05/hello-world/"/>
      <url>/2021/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
