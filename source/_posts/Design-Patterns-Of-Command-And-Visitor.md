---
title: Design Patterns Of Command And Visitor
author: NaiveKyo
top: false
hide: false
img: 'https://cdn.jsdelivr.net/gh/NaiveKyo/CDN/img/20220225221353.jpg'
coverImg: /img/20220225221353.jpg
cover: false
toc: true
mathjax: false
date: 2022-04-22 10:38:50
summary: "设计模式之命令模式、访问者模式"
categories: "Design Patterns"
keywords: "Design Patterns"
tags: "Design Patterns"
---

# 一、命令模式

在软件开发系统中，“方法的请求者”与“方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与实现者解耦？”变得很重要，命令模式就能很好地解决这个问题。



在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。



再比如，我们去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现。



## 1、定义和特点

定义：

- 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。



主要优点：

- 通过引入中间件（抽象接口）降低系统的耦合度。
- 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。
- 可以实现宏命令。命令模式可以与 `组合模式` 结合，将多个命令装配成一个组合命令，即宏命令。
- 方便实现 Undo 和 Redo 操作，命令模式可以与后面介绍的 `备忘录模式` 结合，实现命令的撤销与恢复。
- 可以在现有命令的基础上，增加额外功能。比如日志记录，结合 `装饰器模式`会更加灵活。



缺点：

- 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。
- 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。



## 2、结构和实现

可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。

> 模式的结构

命令模式主要包含以下角色：

- 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
- 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
- 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
- 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

![](https://cdn.jsdelivr.net/gh/NaiveKyo/CDN/img/20220425104027.png)

## 3、案例分析

看 idea 代码，值得研究



## 4、源码分析

- 命令模式在 Spring 框架 JdbcTemplate 中的应用



## 5、注意事项和细节

- 将发起请求的对应与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 `execute()` 方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者“ 和 ”请求执行者“ 之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用
- 容易设计一个命令队列。只要把命令对象放到队列，就可以多线程的执行命令
- 容易实现对请求的撤销和重做
- 命令模式的不足之处：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意
- `空命令` 也是一种设计模式，它帮我们省去了判空的操作。
- 命令模式经典的应用场景：界面的一个按钮就是一条命令、模拟 CMD、订单的撤销/恢复、触发-反馈机制 



## 6、扩展

在软件开发中，有时将命令模式与前面学的组合模式联合使用，这就构成了宏命令模式，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令。

http://c.biancheng.net/view/1380.html



# 二、访问者模式

在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。



这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。



这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。





## 1、模式定义与特点

定义：

访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。



访问者（Visitor）模式是一种`对象行为型模式`，其主要优点如下：

- 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
- 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
- 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
- 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。



访问者（Visitor）模式的主要缺点如下：

- 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
- 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
- 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。 

> 基本介绍

- visitor 主要将数据结构与数据操作分离，解决 **数据结构** 和 **操作耦合性** 问题
- 访问者模式的基本工作原理：在被访问的类里面加上一个对外提供访问者的接口
- 访问者模式的主要应用场景：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作 “污染” 这些对象的类，可以选用访问者模式解决

## 2、模式结构和实现



访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类，其基本结构与实现方法如下。



> 模式的结构

访问者模式包含以下主要角色。

- 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
- 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
- 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
- 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
- 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。

![](https://cdn.jsdelivr.net/gh/NaiveKyo/CDN/img/20220425104059.png)

​	



## 3、**双分派**

- 所谓双分派 是指不管类怎么变化，我们都能找到期望的方法运行，双分派意味着得到执行的操作取决于请求的种类和两个接受者的类型

```java
/**
 * 说明：
 * 1. 这里我们使用了双分派，即首先在客户端程序中将具体的状态作为参数传递到 Woman，完成一次分派
 * 2. 然后，这个 Woman 类，调用作为参数的“具体方法”中的 getWomanResult，同时将自己 this 作为参数
 *    传入，完成了第二次分派
 */
public class Woman extends PersonElement {
    @Override
    public void accept(ActionVisitor actionVisitor) {
        actionVisitor.getWomanResult(this);
    }
}
```



## 4、注意事项和细节

优点：

- 访问者模式符合单一职责原则，让程序具有优秀的扩展性、灵活性非常高
- 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，使用于数据结构相对稳定的系统



缺点：

- 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这也造成了具体元素变更比较困难

- 违背了依赖倒置原则。访问者依赖的是具体元素，而不是抽象元素

- 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较适合的

  

## 5、应用场景和扩展

当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。



简而言之，就是当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式。



通常在以下情况可以考虑使用访问者（Visitor）模式。

- 对象结构相对稳定，但其操作算法经常变化的程序。
- 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。
- 对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。



扩展：

访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。

- 与 `迭代器模式` 联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。
- 访问者（Visitor）模式同 `组合模式` 联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式

![](https://cdn.jsdelivr.net/gh/NaiveKyo/CDN/img/20220425104112.png)