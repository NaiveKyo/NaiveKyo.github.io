---
title: Expression learning Of Regular Expression
author: NaiveKyo
top: false
hide: false
img: 'https://cdn.jsdelivr.net/gh/NaiveKyo/CDN/img/20220425110410.jpg'
coverImg: /img/20220425110410.jpg
cover: false
toc: true
mathjax: false
date: 2022-08-06 18:10:54
summary: "正则表达式学习"
categories: "Expression"
keywords: [Expression, "Regular expression"]
tags: "Expression"
---

# 一、简介

本文源自：https://deerchao.cn/tutorials/regex/regex.htm

在处理字符串的时候，经常有一些查找符合复杂规则的字符串的需要，可以通过一些算法来完成，也可以通过正则表达式去实现。

# 二、概念

## 1、元字符

| 代码 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| `.`  | 匹配除了换行符以外的其他字符                                 |
| `\w` | 匹配字母或数字或下划线或汉字                                 |
| `\s` | 匹配任意的空白符（包括空格、制表符（Tab）、换行符、中文全角空格等等） |
| `\d` | 匹配数字                                                     |
| `\b` | 匹配单词的开始或结束                                         |
| `^`  | 匹配字符串的开始                                             |
| `$`  | 匹配字符串的结束                                             |

> 字符转义

当我们要查找的字符和正则表达式的元字符一致时，可以使用反斜杠 `\` 来转义，比如要查找 `.` 可以使用 `\.`，	查找 `\`，就需要使用 `\\`。

## 2、重复

上面的元字符往往可以表示字符、位置，而表示重复的则是另外的正则表达式中所谓的**限定符（指定数量）**：

| 代码/语法 | 说明               |
| --------- | ------------------ |
| `*`       | 重复零次或者更多次 |
| `+`       | 重复一次或者更多次 |
| `?`       | 重复一次或零次     |
| `{n}`     | 重复 n 次          |
| `{n,}`    | 重复 n 次或更多次  |
| `{n,m}`   | 重复 n 到 m 次     |

## 3、字符类

在查找字母、数字或者空白时使用元字符会很方便，但是如果要查询元字符没有匹配的字符又该怎么办呢？

此时只需要使用 `[]` 将要查找的字符括起来就可以了，比如：

- `[aeiou]` 匹配任何一个英文元音字母；
- `[.?!]` 匹配标点符号（`.`、`?`、`!` 中的某一个），注意这里的 `?` 虽然是正则表达式中的元字符，但是此处不需要转义。

## 4、分枝条件

当要匹配的字符串分为多种模式时，可以使用正则表达式的分枝条件。正则表达式里的分枝条件意思是：有几种规则，如果满足了其中任意一种规则都应该当成匹配。具体使用规则是通过 `|` 将不同的规则分隔开。

比如：

- 以字母 a 开头的字符串后面跟 2 或 3 个数字然后是任意多个字符：
  - 普通版本：`^a\d{2,3}\w+$`
  - 分枝版本：`^a\d\d\w+$|^a\d\d\d\w+$`（这里为了演示效果，所以比较冗长）

## 5、分组

前面提到的正则表达式的重复是有一定的限制的，它只能匹配某个位置或者任意单个字符重复出现的次数，如果要重复多个字符又该怎么办呢？此时可以使用小括号来指定 **子表达式**（也叫做 **分组**），然后就可以指定这个表达式的重复次数了，甚至可以对子表达式做一些操作。

这里以匹配 IP 地址为例：

- IP 地址的格式通常为：`255.255.255.255`，分为 4 段，每段的取值范围是 `[0, 255]`
- 单独匹配某个段可以这样写：`2[0-4]\d|25[0-5]|[01]?\d\d?`
- 完整正则表达式：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

## 6、反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到 **反义**。

| 代码/语法  | 说明                                       |
| ---------- | ------------------------------------------ |
| `\W`       | 匹配任意不是字母、数字、下划线、汉字的字符 |
| `\S`       | 匹配任意不是空白符的字符                   |
| `\D`       | 匹配任意非数字的字符                       |
| `\B`       | 匹配不是单词开头或结束的位置               |
| `[^x]`     | 匹配除了 x 以外的任意字符                  |
| `[^aeiou]` | 匹配除了 aeiou 这几个字母以外的任意字符    |



## 7、后向引用

使用小括号指定一个子表单式后，**匹配这个子表达式的文本**（也就是该分组捕获的内容）可以在表达式或者其他程序中做进一步处理。默认情况下，每个分组会自动拥有一个 **组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。

注意有几个特殊点：

- 整个表达式有一个组号 0；
- 组号匹配过程需要从左向右扫描两遍：第一遍只给未命名分组分配，第二遍只给命名分组分配，因此所有拥有命名组号的分组的组号都大于未命名的分组的组号；
- 可以使用 `(?:exp)` 这样的语法来剥夺一个分组对组号分配的参与权。

**后向引用** 用于重复搜索前面某个分组匹配的文本。例如：`\1` 代表分组 1 匹配的文本。

`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词。例如 `go go` 这样的，分析表达式可知，首先 `\b(\w+)\b` 表示单词开始和结束中间有至少一个字母或数字，这个单词会被捕获到编号为 1 的分组中，然后是 1 个或者多个空白符 `\s+`，最后是分组 1 捕获的内容（也就是前面捕获到的那个单词）`\1`。

当然也可以指定子表达式的组名。可以使用这样的语法 `(?<myGroup>\w+)`（ps：把尖括号换成 `'` 也可以：`(?'myGroup'\w+)`），这样就把 `\w+` 的组名指定为 myGroup 了。要反向引用这个分组捕获的内容，可以使用 `\k<myGroup>`，所以之前捕获连续两个以空白符隔开的单词可以这样写：`\b(?<repeatWord>\w+)\b\s+\k<repeatWord>\b`。

使用小括号的时候，还有许多用法，下面列举出常用的分组语法：

（注：exp 代表表达式）

<table>
    <tr>
    	<th>分类</th><th>代码/语法</th><th>说明</th>
    </tr>
    <tr>
    	<td rowspan='3'>捕获</td>
        <td><code>(exp)</code></td><td>匹配 exp, 并捕获文本到自动命名的组里</td>
    </tr>
    <tr>
        <td><code>(?<name>exp)</code></td><td>匹配 exp, 并捕获文本到名称为 name 的组里, 也可以写成 <code>(?'name'exp)</code></td>
    </tr>
    <tr>
    	<td><code>(?:exp)</code></td><td>匹配 exp, 不捕获匹配的文本, 也不给此分组分配组号</td>
    </tr>
    <tr>
    	<td rowspan='4'>零宽断言</td>
        <td><code>(?=exp)</code></td><td>匹配 exp 前面的位置</td>
    </tr>
    <tr>
    	<td><code>(?&lt;=exp)</code></td><td>匹配 exp 后面的位置</td>
    </tr>
    <tr>
    	<td><code>(?!exp)</code></td><td>匹配后面跟的不是 exp 的位置</td>
    </tr>
    <tr>
    	<td><code>(?&lt;!exp)</code></td><td>匹配前面跟的不是 exp 的位置</td>
    </tr>
    <tr>
    	<td>注释</td><td><code>(?#comment)</code></td><td>这种类型的分组不会正则表达式的处理产生任何影响, 仅仅用于提供注释让人阅读</td>
    </tr>
</table>

## 8、零宽断言

断言用来声明一个应该为真的事实，正则表达式中只有当断言为真时才会继续进行匹配。

零宽断言用于匹配位置，这个位置满足一定的条件（即断言），因此它们也被成为 **零宽断言**。

- `(?=exp)` 也叫做 **零宽度正预测先行断言**，它断言自身出现的位置的后面能够匹配表达式 exp；
  - 比如 `\b\w+(?=ing\b)`，匹配以 ing 结尾的单词前面的部分。
- `(?<=exp)` 也叫做 **零宽度正回顾后发断言**，它断言自身出现的位置的前面能够匹配表达式 exp；
  - 比如 `(?<=\bre)\w+\b` 会匹配以 re 开头的单词的后半部分。



## 9、负向零宽断言

前面提到了反义的概念，就是匹配不在某个字符或字符类中的字符。但是如果我们只是想要 **确保某个字符没有出现，但并不想去匹配它**，此时该怎么做？

例如：查找这样的单词，它里面出现了字母 q，但是 q 后面跟的不是字母 u，可以这样尝试：

- `\b\w*q[^u]\w*\b` 匹配包含后面不是 u 的字母 q 的单词，但是当 q 出现在单词的末尾，这个表达式就会匹配失败，比如 `lraq`，因为 `[^u]` 总是需要匹配一个字符，如果说单词后面跟了空白符或者逗号，那么 `[^u]` 将会匹配成功，介者 `\w*\b` 就会匹配另外一个单词，比如 `lraq xerwr`。
- **负向零宽断言** 就能解决这样的问题，因为它只匹配一个位置，并不 **消费** 任何字符。现在可以使用这样的表达式：`\b\w*q(?!u)\w*\b`。

- **零宽度负预测先行断言** `(?!exp)`：断言此位置的后面不能匹配表达式 exp；
  - 例如：`\d{3}(?!\d)`，匹配三位数字，而且这三位数字后面不能跟数字；
  - `\b((?!abc)\w)+\b`，匹配不包含连续字符 abc 的单词；
- **零宽度负回顾后发断言** `(?<!exp)`：断言此位置的前面不能匹配表达式 exp；
  - 例如：`(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字。

一个简单的例子用于匹配不带属性的 HTML 标签对：`(?<=<(\w+)>).*(?=<\/\1>)`：

（1）注意 `(?<=<(\w+)>)` 指定了这样的 **前缀**：被尖括号括起来的单词；

（2）然后是 `.*` 用于匹配除了换行符以外任意的字符串；

（3）最后是一个 **后缀** `(?=<\/\1>)`，注意这里用到了转义 `\/`，`\1` 是一个反向引用，引用的是捕获的第一组，即前面 `\w+` 捕获的内容。

这里有个注意点零宽断言本身的一对圆括号不参与组号的分配。

## 10、注释

小括号的另外一种用途就是通过语法 `(?#comment)` 来包含注释，但是需要注意的是注释里面不要包含其他特殊的符号。

## 11、贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在整个表达式都匹配的前提下）匹配 **尽可能多的** 字符。

例如：`a.*b`，它将匹配最长的以 a 为开头，以 b 结束的字符串，如果用它来搜索 `aabab`，它会匹配整个字符串。这被成为 **贪婪** 匹配。

有时，我们需要 **懒惰** 匹配，也就是匹配 **尽可能少的** 字符。前面给出的限定符都可以被转换为懒惰匹配模式，只要在它们后面追加上一个 `?`，这样的 `.*?` 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

例如：

- `a.*?b` 匹配最短的，以 a 开始，以 b 结束的字符串，如果用于匹配 aabab 的话，它会匹配 aab 和 ab。

懒惰限定符：

| 代码/语法 | 说明                               |
| --------- | ---------------------------------- |
| `*?`      | 重复任意次，但尽可能少的重复       |
| `+?`      | 重复 1 次或多次，但尽可能少的重复  |
| `??`      | 重复 0 次或 1 次，但尽可能少的重复 |
| `{n,m}?`  | 重复 n 到 m 次，但尽可能少的重复   |
| `{n,}?`   | 重复 n 次以上，但尽可能少的重复    |

## 12、Java 正则表达式

在正则表达式中，某些选项可以改变处理正则表达式的方式，在 Java 中：

- `java.util.regex.Pattern`：一个正则表达式的编译表示，无公共构造函数，只能通过静态方法 `complie` 获取对象；
- `java.util.regex.Matcher`：对输入字符串进行解释和匹配，无公共构造方法，可以通过 `Pattern` 对象的 `matcher`  方法获得一个 `Matcher` 对象；

举几个例子：

```java
@Test
public void test() {
    Pattern compile = Pattern.compile("a.*?b");
    Matcher matcher = compile.matcher("aabab");

    if (matcher.find()) {
        System.out.println("start: " + matcher.start() + " end: " + matcher.end());
    }
}
```

输出结果：

```
start: 0 end: 3
start: 3 end: 5
```

```java
@Test
public void test() {

    String patStr = "(\\D*)(\\d+)(.*)";
    String textStr = "The price of the shirt is 9 pounds and 15 pence";

    Pattern p2 = Pattern.compile(patStr);
    Matcher m2 = p2.matcher(textStr);

    if (m2.find()) {
        int groupCount = m2.groupCount();
        for (int i = 0; i < groupCount; i++) {
            // 注意 0 号分组代表整个表达式匹配
            System.out.println(m2.group(i));
        }
    }
}
```

输出结果：

```
The price of the shirt is 9 pounds and 15 pence
The price of the shirt is 
9
```

```java
@Test
public void test() {

    // 分组号
    Pattern p3 = Pattern.compile("(\\d{3})\\d{4}(\\d{3})");
    Matcher m3 = p3.matcher("1112222333");
    System.out.println(m3.replaceAll("$1****$2"));
    
    // 分组名
    Pattern p3 = Pattern.compile("(?<one>\\d{3})\\d{4}(?<two>\\d{3})");
    Matcher m3 = p3.matcher("1112222333");
    System.out.println(m3.replaceAll("${one}****${two}"));
}
```

输出结果：

```
111****333
```

注意，这里使用 `$` + 分组号或分组名的形式来获取分组捕获的内容。

## 13、处理选项

以 Java 为例，在构造 `Pattern` 的时候可以传入一些选项来改变处理正则表达式的方式，比如下面的：

`public static Pattern compile(String regex, int flags)`

这里的 flag 对应 Pattern 类的静态成员变量：

```java
public static final int UNIX_LINES = 0x01;
public static final int CASE_INSENSITIVE = 0x02;
public static final int COMMENTS = 0x04;
public static final int MULTILINE = 0x08;
public static final int LITERAL = 0x10;
public static final int DOTALL = 0x20;
public static final int UNICODE_CASE = 0x40;
public static final int CANON_EQ = 0x80;
public static final int UNICODE_CHARACTER_CLASS = 0x100;
private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |
            DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |
            UNICODE_CHARACTER_CLASS | COMMENTS;
```

具体参考注释，这里举出常用的：

| 名称             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| UNIX_LINES       | `Unix line` 模式下 `.`、`^`、`$` 仅仅识别 `\n` 换行符        |
| CASE_INSENSITIVE | 大小写不敏感，匹配时不区分大小写                             |
| COMMENTS         | 允许注释，空白字符被忽略，注释中 `#`  后面一整行被忽略       |
| MULTILINE        | 更改 `^` 和 `$` 的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,`$` 的精确含意是: 匹配 `\n` 之前的位置以及字符串结束前的位置。) |
| DOTALL           | 更改 `.` 的含义，使其与每一个字符匹配，包括 `\n`             |

# 三、TODO